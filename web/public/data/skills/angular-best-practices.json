{
  "id": "antigravity-angular-best-practices",
  "name": "angular-best-practices",
  "slug": "angular-best-practices",
  "description": "Angular performance optimization and best practices guide. Use when writing, reviewing, or refactoring Angular code for optimal performance, bundle size, and rendering efficiency.",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/angular-best-practices",
  "content": "\n# Angular Best Practices\n\nComprehensive performance optimization guide for Angular applications. Contains prioritized rules for eliminating performance bottlenecks, optimizing bundles, and improving rendering.\n\n## When to Apply\n\nReference these guidelines when:\n\n- Writing new Angular components or pages\n- Implementing data fetching patterns\n- Reviewing code for performance issues\n- Refactoring existing Angular code\n- Optimizing bundle size or load times\n- Configuring SSR/hydration\n\n---\n\n## Rule Categories by Priority\n\n| Priority | Category              | Impact     | Focus                           |\n| -------- | --------------------- | ---------- | ------------------------------- |\n| 1        | Change Detection      | CRITICAL   | Signals, OnPush, Zoneless       |\n| 2        | Async Waterfalls      | CRITICAL   | RxJS patterns, SSR preloading   |\n| 3        | Bundle Optimization   | CRITICAL   | Lazy loading, tree shaking      |\n| 4        | Rendering Performance | HIGH       | @defer, trackBy, virtualization |\n| 5        | Server-Side Rendering | HIGH       | Hydration, prerendering         |\n| 6        | Template Optimization | MEDIUM     | Control flow, pipes             |\n| 7        | State Management      | MEDIUM     | Signal patterns, selectors      |\n| 8        | Memory Management     | LOW-MEDIUM | Cleanup, subscriptions          |\n\n---\n\n## 1. Change Detection (CRITICAL)\n\n### Use OnPush Change Detection\n\n```typescript\n// CORRECT - OnPush with Signals\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `<div>{{ count() }}</div>`,\n})\nexport class CounterComponent {\n  count = signal(0);\n}\n\n// WRONG - Default change detection\n@Component({\n  template: `<div>{{ count }}</div>`, // Checked every cycle\n})\nexport class CounterComponent {\n  count = 0;\n}\n```\n\n### Prefer Signals Over Mutable Properties\n\n```typescript\n// CORRECT - Signals trigger precise updates\n@Component({\n  template: `\n    <h1>{{ title() }}</h1>\n    <p>Count: {{ count() }}</p>\n  `,\n})\nexport class DashboardComponent {\n  title = signal(\"Dashboard\");\n  count = signal(0);\n}\n\n// WRONG - Mutable properties require zone.js checks\n@Component({\n  template: `\n    <h1>{{ title }}</h1>\n    <p>Count: {{ count }}</p>\n  `,\n})\nexport class DashboardComponent {\n  title = \"Dashboard\";\n  count = 0;\n}\n```\n\n### Enable Zoneless for New Projects\n\n```typescript\n// main.ts - Zoneless Angular (v20+)\nbootstrapApplication(AppComponent, {\n  providers: [provideZonelessChangeDetection()],\n});\n```\n\n**Benefits:**\n\n- No zone.js patches on async APIs\n- Smaller bundle (~15KB savings)\n- Clean stack traces for debugging\n- Better micro-frontend compatibility\n\n---\n\n## 2. Async Operations & Waterfalls (CRITICAL)\n\n### Eliminate Sequential Data Fetching\n\n```typescript\n// WRONG - Nested subscriptions create waterfalls\nthis.route.params.subscribe((params) => {\n  // 1. Wait for params\n  this.userService.getUser(params.id).subscribe((user) => {\n    // 2. Wait for user\n    this.postsService.getPosts(user.id).subscribe((posts) => {\n      // 3. Wait for posts\n    });\n  });\n});\n\n// CORRECT - Parallel execution with forkJoin\nforkJoin({\n  user: this.userService.getUser(id),\n  posts: this.postsService.getPosts(id),\n}).subscribe((data) => {\n  // Fetched in parallel\n});\n\n// CORRECT - Flatten dependent calls with switchMap\nthis.route.params\n  .pipe(\n    map((p) => p.id),\n    switchMap((id) => this.userService.getUser(id)),\n  )\n  .subscribe();\n```\n\n### Avoid Client-Side Waterfalls in SSR\n\n```typescript\n// CORRECT - Use resolvers or blocking hydration for critical data\nexport const route: Route = {\n  path: \"profile/:id\",\n  resolve: { data: profileResolver }, // Fetched on server before navigation\n  component: ProfileComponent,\n};\n\n// WRONG - Component fetches data on init\nclass ProfileComponent implements OnInit {\n  ngOnInit() {\n    // Starts ONLY after JS loads and component renders\n    this.http.get(\"/api/profile\").subscribe();\n  }\n}\n```\n\n---\n\n## 3. Bundle Optimization (CRITICAL)\n\n### Lazy Load Routes\n\n```typescript\n// CORRECT - Lazy load feature routes\nexport const routes: Routes = [\n  {\n    path: \"admin\",\n    loadChildren: () =>\n      import(\"./admin/admin.routes\").then((m) => m.ADMIN_ROUTES),\n  },\n  {\n    path: \"dashboard\",\n    loadComponent: () =>\n      import(\"./dashboard/dashboard.component\").then(\n        (m) => m.DashboardComponent,\n      ),\n  },\n];\n\n// WRONG - Eager loading everything\nimport { AdminModule } from \"./admin/admin.module\";\nexport const routes: Routes = [\n  { path: \"admin\", component: AdminComponent }, // In main bundle\n];\n```\n\n### Use @defer for Heavy Components\n\n```html\n<!-- CORRECT - Heavy component loads on demand -->\n@defer (on viewport) {\n<app-analytics-chart [data]=\"data()\" />\n} @placeholder {\n<div class=\"chart-skeleton\"></div>\n}\n\n<!-- WRONG - Heavy component in initial bundle -->\n<app-analytics-chart [data]=\"data()\" />\n```\n\n### Avoid Barrel File Re-exports\n\n```typescript\n// WRONG - Imports entire barrel, breaks tree-shaking\nimport { Button, M",
  "tags": [
    "typescript",
    "api",
    "ai",
    "template",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-02-05T07:07:31.980Z"
}