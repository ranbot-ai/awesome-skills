{
  "id": "antigravity-cc-skill-coding-standards",
  "name": "coding-standards",
  "slug": "cc-skill-coding-standards",
  "description": "Universal coding standards, best practices, and patterns for TypeScript, JavaScript, React, and Node.js development.",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/cc-skill-coding-standards",
  "content": "\n# Coding Standards & Best Practices\n\nUniversal coding standards applicable across all projects.\n\n## Code Quality Principles\n\n### 1. Readability First\n- Code is read more than written\n- Clear variable and function names\n- Self-documenting code preferred over comments\n- Consistent formatting\n\n### 2. KISS (Keep It Simple, Stupid)\n- Simplest solution that works\n- Avoid over-engineering\n- No premature optimization\n- Easy to understand > clever code\n\n### 3. DRY (Don't Repeat Yourself)\n- Extract common logic into functions\n- Create reusable components\n- Share utilities across modules\n- Avoid copy-paste programming\n\n### 4. YAGNI (You Aren't Gonna Need It)\n- Don't build features before they're needed\n- Avoid speculative generality\n- Add complexity only when required\n- Start simple, refactor when needed\n\n## TypeScript/JavaScript Standards\n\n### Variable Naming\n\n```typescript\n// ✅ GOOD: Descriptive names\nconst marketSearchQuery = 'election'\nconst isUserAuthenticated = true\nconst totalRevenue = 1000\n\n// ❌ BAD: Unclear names\nconst q = 'election'\nconst flag = true\nconst x = 1000\n```\n\n### Function Naming\n\n```typescript\n// ✅ GOOD: Verb-noun pattern\nasync function fetchMarketData(marketId: string) { }\nfunction calculateSimilarity(a: number[], b: number[]) { }\nfunction isValidEmail(email: string): boolean { }\n\n// ❌ BAD: Unclear or noun-only\nasync function market(id: string) { }\nfunction similarity(a, b) { }\nfunction email(e) { }\n```\n\n### Immutability Pattern (CRITICAL)\n\n```typescript\n// ✅ ALWAYS use spread operator\nconst updatedUser = {\n  ...user,\n  name: 'New Name'\n}\n\nconst updatedArray = [...items, newItem]\n\n// ❌ NEVER mutate directly\nuser.name = 'New Name'  // BAD\nitems.push(newItem)     // BAD\n```\n\n### Error Handling\n\n```typescript\n// ✅ GOOD: Comprehensive error handling\nasync function fetchData(url: string) {\n  try {\n    const response = await fetch(url)\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Fetch failed:', error)\n    throw new Error('Failed to fetch data')\n  }\n}\n\n// ❌ BAD: No error handling\nasync function fetchData(url) {\n  const response = await fetch(url)\n  return response.json()\n}\n```\n\n### Async/Await Best Practices\n\n```typescript\n// ✅ GOOD: Parallel execution when possible\nconst [users, markets, stats] = await Promise.all([\n  fetchUsers(),\n  fetchMarkets(),\n  fetchStats()\n])\n\n// ❌ BAD: Sequential when unnecessary\nconst users = await fetchUsers()\nconst markets = await fetchMarkets()\nconst stats = await fetchStats()\n```\n\n### Type Safety\n\n```typescript\n// ✅ GOOD: Proper types\ninterface Market {\n  id: string\n  name: string\n  status: 'active' | 'resolved' | 'closed'\n  created_at: Date\n}\n\nfunction getMarket(id: string): Promise<Market> {\n  // Implementation\n}\n\n// ❌ BAD: Using 'any'\nfunction getMarket(id: any): Promise<any> {\n  // Implementation\n}\n```\n\n## React Best Practices\n\n### Component Structure\n\n```typescript\n// ✅ GOOD: Functional component with types\ninterface ButtonProps {\n  children: React.ReactNode\n  onClick: () => void\n  disabled?: boolean\n  variant?: 'primary' | 'secondary'\n}\n\nexport function Button({\n  children,\n  onClick,\n  disabled = false,\n  variant = 'primary'\n}: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className={`btn btn-${variant}`}\n    >\n      {children}\n    </button>\n  )\n}\n\n// ❌ BAD: No types, unclear structure\nexport function Button(props) {\n  return <button onClick={props.onClick}>{props.children}</button>\n}\n```\n\n### Custom Hooks\n\n```typescript\n// ✅ GOOD: Reusable custom hook\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    return () => clearTimeout(handler)\n  }, [value, delay])\n\n  return debouncedValue\n}\n\n// Usage\nconst debouncedQuery = useDebounce(searchQuery, 500)\n```\n\n### State Management\n\n```typescript\n// ✅ GOOD: Proper state updates\nconst [count, setCount] = useState(0)\n\n// Functional update for state based on previous state\nsetCount(prev => prev + 1)\n\n// ❌ BAD: Direct state reference\nsetCount(count + 1)  // Can be stale in async scenarios\n```\n\n### Conditional Rendering\n\n```typescript\n// ✅ GOOD: Clear conditional rendering\n{isLoading && <Spinner />}\n{error && <ErrorMessage error={error} />}\n{data && <DataDisplay data={data} />}\n\n// ❌ BAD: Ternary hell\n{isLoading ? <Spinner /> : error ? <ErrorMessage error={error} /> : data ? <DataDisplay data={data} /> : null}\n```\n\n## API Design Standards\n\n### REST API Conventions\n\n```\nGET    /api/markets              # List all markets\nGET    /api/markets/:id          # Get specific market\nPOST   /api/markets              # Create new market\nPUT    /api/markets/:id          # Update market (full)\nPATCH  /api/markets/:id          # Update market (partial)\nDELETE /api/markets/:id         ",
  "tags": [
    "javascript",
    "typescript",
    "react",
    "node",
    "api",
    "ai",
    "design",
    "document",
    "supabase",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-26T13:17:21.842Z"
}