{
  "id": "antigravity-shellcheck-configuration",
  "name": "shellcheck-configuration",
  "slug": "shellcheck-configuration",
  "description": "Master ShellCheck static analysis configuration and usage for shell script quality. Use when setting up linting infrastructure, fixing code issues, or ensuring script portability.",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/shellcheck-configuration",
  "content": "\n# ShellCheck Configuration and Static Analysis\n\nComprehensive guidance for configuring and using ShellCheck to improve shell script quality, catch common pitfalls, and enforce best practices through static code analysis.\n\n## Do not use this skill when\n\n- The task is unrelated to shellcheck configuration and static analysis\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\n## Use this skill when\n\n- Setting up linting for shell scripts in CI/CD pipelines\n- Analyzing existing shell scripts for issues\n- Understanding ShellCheck error codes and warnings\n- Configuring ShellCheck for specific project requirements\n- Integrating ShellCheck into development workflows\n- Suppressing false positives and configuring rule sets\n- Enforcing consistent code quality standards\n- Migrating scripts to meet quality gates\n\n## ShellCheck Fundamentals\n\n### What is ShellCheck?\n\nShellCheck is a static analysis tool that analyzes shell scripts and detects problematic patterns. It supports:\n- Bash, sh, dash, ksh, and other POSIX shells\n- Over 100 different warnings and errors\n- Configuration for target shell and flags\n- Integration with editors and CI/CD systems\n\n### Installation\n\n```bash\n# macOS with Homebrew\nbrew install shellcheck\n\n# Ubuntu/Debian\napt-get install shellcheck\n\n# From source\ngit clone https://github.com/koalaman/shellcheck.git\ncd shellcheck\nmake build\nmake install\n\n# Verify installation\nshellcheck --version\n```\n\n## Configuration Files\n\n### .shellcheckrc (Project Level)\n\nCreate `.shellcheckrc` in your project root:\n\n```\n# Specify target shell\nshell=bash\n\n# Enable optional checks\nenable=avoid-nullary-conditions\nenable=require-variable-braces\n\n# Disable specific warnings\ndisable=SC1091\ndisable=SC2086\n```\n\n### Environment Variables\n\n```bash\n# Set default shell target\nexport SHELLCHECK_SHELL=bash\n\n# Enable strict mode\nexport SHELLCHECK_STRICT=true\n\n# Specify configuration file location\nexport SHELLCHECK_CONFIG=~/.shellcheckrc\n```\n\n## Common ShellCheck Error Codes\n\n### SC1000-1099: Parser Errors\n```bash\n# SC1004: Backslash continuation not followed by newline\necho hello\\\nworld  # Error - needs line continuation\n\n# SC1008: Invalid data for operator `=='\nif [[ $var =  \"value\" ]]; then  # Space before ==\n    true\nfi\n```\n\n### SC2000-2099: Shell Issues\n\n```bash\n# SC2009: Consider using pgrep or pidof instead of grep|grep\nps aux | grep -v grep | grep myprocess  # Use pgrep instead\n\n# SC2012: Use `ls` only for viewing. Use `find` for reliable output\nfor file in $(ls -la)  # Better: use find or globbing\n\n# SC2015: Avoid using && and || instead of if-then-else\n[[ -f \"$file\" ]] && echo \"found\" || echo \"not found\"  # Less clear\n\n# SC2016: Expressions don't expand in single quotes\necho '$VAR'  # Literal $VAR, not variable expansion\n\n# SC2026: This word is non-standard. Set POSIXLY_CORRECT\n# when using with scripts for other shells\n```\n\n### SC2100-2199: Quoting Issues\n\n```bash\n# SC2086: Double quote to prevent globbing and word splitting\nfor i in $list; do  # Should be: for i in $list or for i in \"$list\"\n    echo \"$i\"\ndone\n\n# SC2115: Literal tilde in path not expanded. Use $HOME instead\n~/.bashrc  # In strings, use \"$HOME/.bashrc\"\n\n# SC2181: Check exit code directly with `if`, not indirectly in a list\nsome_command\nif [ $? -eq 0 ]; then  # Better: if some_command; then\n\n# SC2206: Quote to prevent word splitting or set IFS\narray=( $items )  # Should use: array=( $items )\n```\n\n### SC3000-3999: POSIX Compliance Issues\n\n```bash\n# SC3010: In POSIX sh, use 'case' instead of 'cond && foo'\n[[ $var == \"value\" ]] && do_something  # Not POSIX\n\n# SC3043: In POSIX sh, use 'local' is undefined\nfunction my_func() {\n    local var=value  # Not POSIX in some shells\n}\n```\n\n## Practical Configuration Examples\n\n### Minimal Configuration (Strict POSIX)\n\n```bash\n#!/bin/bash\n# Configure for maximum portability\n\nshellcheck \\\n  --shell=sh \\\n  --external-sources \\\n  --check-sourced \\\n  script.sh\n```\n\n### Development Configuration (Bash with Relaxed Rules)\n\n```bash\n#!/bin/bash\n# Configure for Bash development\n\nshellcheck \\\n  --shell=bash \\\n  --exclude=SC1091,SC2119 \\\n  --enable=all \\\n  script.sh\n```\n\n### CI/CD Integration Configuration\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Analyze all shell scripts and fail on issues\nfind . -type f -name \"*.sh\" | while read -r script; do\n    echo \"Checking: $script\"\n    shellcheck \\\n        --shell=bash \\\n        --format=gcc \\\n        --exclude=SC1091 \\\n        \"$script\" || exit 1\ndone\n```\n\n### .shellcheckrc for Project\n\n```\n# Shell dialect to analyze against\nshell=bash\n\n# Enable optional checks\nenable=avoid-nullary-conditions,require-variable-braces,check-unassigned-uppercase\n\n# Disable specific warnings\n# SC1091: Not following sourced files (many false positives)\ndisable",
  "tags": [
    "ai",
    "workflow",
    "document",
    "image"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:00:30.212Z"
}