{
  "id": "antigravity-javascript-mastery",
  "name": "javascript-mastery",
  "slug": "javascript-mastery",
  "description": "Comprehensive JavaScript reference covering 33+ essential concepts every developer should know. From fundamentals like primitives and closures to advanced patterns like async/await and functional programming. Use when explaining JS concepts, debugging JavaScript issues, or teaching JavaScript fundam",
  "category": "Development & Code Tools",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/javascript-mastery",
  "content": "\n# ðŸ§  JavaScript Mastery\n\n> 33+ essential JavaScript concepts every developer should know, inspired by [33-js-concepts](https://github.com/leonardomso/33-js-concepts).\n\n## When to Use This Skill\n\nUse this skill when:\n\n- Explaining JavaScript concepts\n- Debugging tricky JS behavior\n- Teaching JavaScript fundamentals\n- Reviewing code for JS best practices\n- Understanding language quirks\n\n---\n\n## 1. Fundamentals\n\n### 1.1 Primitive Types\n\nJavaScript has 7 primitive types:\n\n```javascript\n// String\nconst str = \"hello\";\n\n// Number (integers and floats)\nconst num = 42;\nconst float = 3.14;\n\n// BigInt (for large integers)\nconst big = 9007199254740991n;\n\n// Boolean\nconst bool = true;\n\n// Undefined\nlet undef; // undefined\n\n// Null\nconst empty = null;\n\n// Symbol (unique identifiers)\nconst sym = Symbol(\"description\");\n```\n\n**Key points**:\n\n- Primitives are immutable\n- Passed by value\n- `typeof null === \"object\"` is a historical bug\n\n### 1.2 Type Coercion\n\nJavaScript implicitly converts types:\n\n```javascript\n// String coercion\n\"5\" + 3; // \"53\" (number â†’ string)\n\"5\" - 3; // 2    (string â†’ number)\n\n// Boolean coercion\nBoolean(\"\"); // false\nBoolean(\"hello\"); // true\nBoolean(0); // false\nBoolean([]); // true (!)\n\n// Equality coercion\n\"5\" == 5; // true  (coerces)\n\"5\" === 5; // false (strict)\n```\n\n**Falsy values** (8 total):\n`false`, `0`, `-0`, `0n`, `\"\"`, `null`, `undefined`, `NaN`\n\n### 1.3 Equality Operators\n\n```javascript\n// == (loose equality) - coerces types\nnull == undefined; // true\n\"1\" == 1; // true\n\n// === (strict equality) - no coercion\nnull === undefined; // false\n\"1\" === 1; // false\n\n// Object.is() - handles edge cases\nObject.is(NaN, NaN); // true (NaN === NaN is false!)\nObject.is(-0, 0); // false (0 === -0 is true!)\n```\n\n**Rule**: Always use `===` unless you have a specific reason not to.\n\n---\n\n## 2. Scope & Closures\n\n### 2.1 Scope Types\n\n```javascript\n// Global scope\nvar globalVar = \"global\";\n\nfunction outer() {\n  // Function scope\n  var functionVar = \"function\";\n\n  if (true) {\n    // Block scope (let/const only)\n    let blockVar = \"block\";\n    const alsoBlock = \"block\";\n    var notBlock = \"function\"; // var ignores blocks!\n  }\n}\n```\n\n### 2.2 Closures\n\nA closure is a function that remembers its lexical scope:\n\n```javascript\nfunction createCounter() {\n  let count = 0; // \"closed over\" variable\n\n  return {\n    increment() {\n      return ++count;\n    },\n    decrement() {\n      return --count;\n    },\n    getCount() {\n      return count;\n    },\n  };\n}\n\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.getCount(); // 2\n```\n\n**Common use cases**:\n\n- Data privacy (module pattern)\n- Function factories\n- Partial application\n- Memoization\n\n### 2.3 var vs let vs const\n\n```javascript\n// var - function scoped, hoisted, can redeclare\nvar x = 1;\nvar x = 2; // OK\n\n// let - block scoped, hoisted (TDZ), no redeclare\nlet y = 1;\n// let y = 2; // Error!\n\n// const - like let, but can't reassign\nconst z = 1;\n// z = 2; // Error!\n\n// BUT: const objects are mutable\nconst obj = { a: 1 };\nobj.a = 2; // OK\nobj.b = 3; // OK\n```\n\n---\n\n## 3. Functions & Execution\n\n### 3.1 Call Stack\n\n```javascript\nfunction first() {\n  console.log(\"first start\");\n  second();\n  console.log(\"first end\");\n}\n\nfunction second() {\n  console.log(\"second\");\n}\n\nfirst();\n// Output:\n// \"first start\"\n// \"second\"\n// \"first end\"\n```\n\nStack overflow example:\n\n```javascript\nfunction infinite() {\n  infinite(); // No base case!\n}\ninfinite(); // RangeError: Maximum call stack size exceeded\n```\n\n### 3.2 Hoisting\n\n```javascript\n// Variable hoisting\nconsole.log(a); // undefined (hoisted, not initialized)\nvar a = 5;\n\nconsole.log(b); // ReferenceError (TDZ)\nlet b = 5;\n\n// Function hoisting\nsayHi(); // Works!\nfunction sayHi() {\n  console.log(\"Hi!\");\n}\n\n// Function expressions don't hoist\nsayBye(); // TypeError\nvar sayBye = function () {\n  console.log(\"Bye!\");\n};\n```\n\n### 3.3 this Keyword\n\n```javascript\n// Global context\nconsole.log(this); // window (browser) or global (Node)\n\n// Object method\nconst obj = {\n  name: \"Alice\",\n  greet() {\n    console.log(this.name); // \"Alice\"\n  },\n};\n\n// Arrow functions (lexical this)\nconst obj2 = {\n  name: \"Bob\",\n  greet: () => {\n    console.log(this.name); // undefined (inherits outer this)\n  },\n};\n\n// Explicit binding\nfunction greet() {\n  console.log(this.name);\n}\ngreet.call({ name: \"Charlie\" }); // \"Charlie\"\ngreet.apply({ name: \"Diana\" }); // \"Diana\"\nconst bound = greet.bind({ name: \"Eve\" });\nbound(); // \"Eve\"\n```\n\n---\n\n## 4. Event Loop & Async\n\n### 4.1 Event Loop\n\n```javascript\nconsole.log(\"1\");\n\nsetTimeout(() => console.log(\"2\"), 0);\n\nPromise.resolve().then(() => console.log(\"3\"));\n\nconsole.log(\"4\");\n\n// Output: 1, 4, 3, 2\n// Why? Microtasks (Promises) run before macrotasks (setTimeout)\n```\n\n**Execution order**:\n\n1. Synchronous code (call stack)\n2. Microtasks (Promise callbacks, queueMicrotask)\n3. Macrotasks (setTimeout, setInterval, I/O)\n\n### 4.2 Callbacks\n\n```javascript\n// Callback pattern\nfunction fetchData",
  "tags": [
    "javascript",
    "node",
    "api",
    "ai",
    "cro"
  ],
  "useCases": [
    "Explaining JavaScript concepts",
    "Debugging tricky JS behavior",
    "Teaching JavaScript fundamentals",
    "Reviewing code for JS best practices",
    "Understanding language quirks"
  ],
  "scrapedAt": "2026-01-26T13:19:08.821Z"
}