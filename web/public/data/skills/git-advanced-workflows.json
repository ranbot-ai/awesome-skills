{
  "id": "antigravity-git-advanced-workflows",
  "name": "git-advanced-workflows",
  "slug": "git-advanced-workflows",
  "description": "Master advanced Git workflows including rebasing, cherry-picking, bisect, worktrees, and reflog to maintain clean history and recover from any situation. Use when managing complex Git histories, collaborating on feature branches, or troubleshooting repository issues.",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/git-advanced-workflows",
  "content": "\n# Git Advanced Workflows\n\nMaster advanced Git techniques to maintain clean history, collaborate effectively, and recover from any situation with confidence.\n\n## Do not use this skill when\n\n- The task is unrelated to git advanced workflows\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\n## Use this skill when\n\n- Cleaning up commit history before merging\n- Applying specific commits across branches\n- Finding commits that introduced bugs\n- Working on multiple features simultaneously\n- Recovering from Git mistakes or lost commits\n- Managing complex branch workflows\n- Preparing clean PRs for review\n- Synchronizing diverged branches\n\n## Core Concepts\n\n### 1. Interactive Rebase\n\nInteractive rebase is the Swiss Army knife of Git history editing.\n\n**Common Operations:**\n- `pick`: Keep commit as-is\n- `reword`: Change commit message\n- `edit`: Amend commit content\n- `squash`: Combine with previous commit\n- `fixup`: Like squash but discard message\n- `drop`: Remove commit entirely\n\n**Basic Usage:**\n```bash\n# Rebase last 5 commits\ngit rebase -i HEAD~5\n\n# Rebase all commits on current branch\ngit rebase -i $(git merge-base HEAD main)\n\n# Rebase onto specific commit\ngit rebase -i abc123\n```\n\n### 2. Cherry-Picking\n\nApply specific commits from one branch to another without merging entire branches.\n\n```bash\n# Cherry-pick single commit\ngit cherry-pick abc123\n\n# Cherry-pick range of commits (exclusive start)\ngit cherry-pick abc123..def456\n\n# Cherry-pick without committing (stage changes only)\ngit cherry-pick -n abc123\n\n# Cherry-pick and edit commit message\ngit cherry-pick -e abc123\n```\n\n### 3. Git Bisect\n\nBinary search through commit history to find the commit that introduced a bug.\n\n```bash\n# Start bisect\ngit bisect start\n\n# Mark current commit as bad\ngit bisect bad\n\n# Mark known good commit\ngit bisect good v1.0.0\n\n# Git will checkout middle commit - test it\n# Then mark as good or bad\ngit bisect good  # or: git bisect bad\n\n# Continue until bug found\n# When done\ngit bisect reset\n```\n\n**Automated Bisect:**\n```bash\n# Use script to test automatically\ngit bisect start HEAD v1.0.0\ngit bisect run ./test.sh\n\n# test.sh should exit 0 for good, 1-127 (except 125) for bad\n```\n\n### 4. Worktrees\n\nWork on multiple branches simultaneously without stashing or switching.\n\n```bash\n# List existing worktrees\ngit worktree list\n\n# Add new worktree for feature branch\ngit worktree add ../project-feature feature/new-feature\n\n# Add worktree and create new branch\ngit worktree add -b bugfix/urgent ../project-hotfix main\n\n# Remove worktree\ngit worktree remove ../project-feature\n\n# Prune stale worktrees\ngit worktree prune\n```\n\n### 5. Reflog\n\nYour safety net - tracks all ref movements, even deleted commits.\n\n```bash\n# View reflog\ngit reflog\n\n# View reflog for specific branch\ngit reflog show feature/branch\n\n# Restore deleted commit\ngit reflog\n# Find commit hash\ngit checkout abc123\ngit branch recovered-branch\n\n# Restore deleted branch\ngit reflog\ngit branch deleted-branch abc123\n```\n\n## Practical Workflows\n\n### Workflow 1: Clean Up Feature Branch Before PR\n\n```bash\n# Start with feature branch\ngit checkout feature/user-auth\n\n# Interactive rebase to clean history\ngit rebase -i main\n\n# Example rebase operations:\n# - Squash \"fix typo\" commits\n# - Reword commit messages for clarity\n# - Reorder commits logically\n# - Drop unnecessary commits\n\n# Force push cleaned branch (safe if no one else is using it)\ngit push --force-with-lease origin feature/user-auth\n```\n\n### Workflow 2: Apply Hotfix to Multiple Releases\n\n```bash\n# Create fix on main\ngit checkout main\ngit commit -m \"fix: critical security patch\"\n\n# Apply to release branches\ngit checkout release/2.0\ngit cherry-pick abc123\n\ngit checkout release/1.9\ngit cherry-pick abc123\n\n# Handle conflicts if they arise\ngit cherry-pick --continue\n# or\ngit cherry-pick --abort\n```\n\n### Workflow 3: Find Bug Introduction\n\n```bash\n# Start bisect\ngit bisect start\ngit bisect bad HEAD\ngit bisect good v2.1.0\n\n# Git checks out middle commit - run tests\nnpm test\n\n# If tests fail\ngit bisect bad\n\n# If tests pass\ngit bisect good\n\n# Git will automatically checkout next commit to test\n# Repeat until bug found\n\n# Automated version\ngit bisect start HEAD v2.1.0\ngit bisect run npm test\n```\n\n### Workflow 4: Multi-Branch Development\n\n```bash\n# Main project directory\ncd ~/projects/myapp\n\n# Create worktree for urgent bugfix\ngit worktree add ../myapp-hotfix hotfix/critical-bug\n\n# Work on hotfix in separate directory\ncd ../myapp-hotfix\n# Make changes, commit\ngit commit -m \"fix: resolve critical bug\"\ngit push origin hotfix/critical-bug\n\n# Return to main work without interruption\ncd ~/projects/myapp\ngit fetch origin\ngit cherry-pick hotfix/critical-bug\n\n# Clean up when done\ngit worktree remove ../myapp-hot",
  "tags": [
    "ai",
    "workflow",
    "security",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:59:10.123Z"
}