{
  "id": "antigravity-fp-ts-react",
  "name": "fp-ts-react",
  "slug": "fp-ts-react",
  "description": "Practical patterns for using fp-ts with React - hooks, state, forms, data fetching. Use when building React apps with functional programming patterns. Works with React 18/19, Next.js 14/15.",
  "category": "Development & Code Tools",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/fp-ts-react",
  "content": "\n# Functional Programming in React\n\nPractical patterns for React apps. No jargon, just code that works.\n\n## When to Use This Skill\n\n- When building React apps with fp-ts for type-safe state management\n- When handling loading/error/success states in data fetching\n- When implementing form validation with error accumulation\n- When using React 18/19 or Next.js 14/15 with functional patterns\n\n---\n\n## Quick Reference\n\n| Pattern | Use When |\n|---------|----------|\n| `Option` | Value might be missing (user not loaded yet) |\n| `Either` | Operation might fail (form validation) |\n| `TaskEither` | Async operation might fail (API calls) |\n| `RemoteData` | Need to show loading/error/success states |\n| `pipe` | Chaining multiple transformations |\n\n---\n\n## 1. State with Option (Maybe It's There, Maybe Not)\n\nUse `Option` instead of `null | undefined` for clearer intent.\n\n### Basic Pattern\n\n```typescript\nimport { useState } from 'react'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: string\n  name: string\n  email: string\n}\n\nfunction UserProfile() {\n  // Option says \"this might not exist yet\"\n  const [user, setUser] = useState<O.Option<User>>(O.none)\n\n  const handleLogin = (userData: User) => {\n    setUser(O.some(userData))\n  }\n\n  const handleLogout = () => {\n    setUser(O.none)\n  }\n\n  return pipe(\n    user,\n    O.match(\n      // When there's no user\n      () => <button onClick={() => handleLogin({ id: '1', name: 'Alice', email: 'alice@example.com' })}>\n        Log In\n      </button>,\n      // When there's a user\n      (u) => (\n        <div>\n          <p>Welcome, {u.name}!</p>\n          <button onClick={handleLogout}>Log Out</button>\n        </div>\n      )\n    )\n  )\n}\n```\n\n### Chaining Optional Values\n\n```typescript\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\ninterface Profile {\n  user: O.Option<{\n    name: string\n    settings: O.Option<{\n      theme: string\n    }>\n  }>\n}\n\nfunction getTheme(profile: Profile): string {\n  return pipe(\n    profile.user,\n    O.flatMap(u => u.settings),\n    O.map(s => s.theme),\n    O.getOrElse(() => 'light') // default\n  )\n}\n```\n\n---\n\n## 2. Form Validation with Either\n\nEither is perfect for validation: `Left` = errors, `Right` = valid data.\n\n### Simple Form Validation\n\n```typescript\nimport * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\n\n// Validation functions return Either<ErrorMessage, ValidValue>\nconst validateEmail = (email: string): E.Either<string, string> =>\n  email.includes('@')\n    ? E.right(email)\n    : E.left('Invalid email address')\n\nconst validatePassword = (password: string): E.Either<string, string> =>\n  password.length >= 8\n    ? E.right(password)\n    : E.left('Password must be at least 8 characters')\n\nconst validateName = (name: string): E.Either<string, string> =>\n  name.trim().length > 0\n    ? E.right(name.trim())\n    : E.left('Name is required')\n```\n\n### Collecting All Errors (Not Just First One)\n\n```typescript\nimport * as E from 'fp-ts/Either'\nimport { sequenceS } from 'fp-ts/Apply'\nimport { getSemigroup } from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\n// This collects ALL errors, not just the first one\nconst validateAll = sequenceS(E.getApplicativeValidation(getSemigroup<string>()))\n\ninterface SignupForm {\n  name: string\n  email: string\n  password: string\n}\n\ninterface ValidatedForm {\n  name: string\n  email: string\n  password: string\n}\n\nfunction validateForm(form: SignupForm): E.Either<string[], ValidatedForm> {\n  return pipe(\n    validateAll({\n      name: pipe(validateName(form.name), E.mapLeft(e => [e])),\n      email: pipe(validateEmail(form.email), E.mapLeft(e => [e])),\n      password: pipe(validatePassword(form.password), E.mapLeft(e => [e])),\n    })\n  )\n}\n\n// Usage in component\nfunction SignupForm() {\n  const [form, setForm] = useState({ name: '', email: '', password: '' })\n  const [errors, setErrors] = useState<string[]>([])\n\n  const handleSubmit = () => {\n    pipe(\n      validateForm(form),\n      E.match(\n        (errs) => setErrors(errs),     // Show all errors\n        (valid) => {\n          setErrors([])\n          submitToServer(valid)         // Submit valid data\n        }\n      )\n    )\n  }\n\n  return (\n    <form onSubmit={e => { e.preventDefault(); handleSubmit() }}>\n      <input\n        value={form.name}\n        onChange={e => setForm(f => ({ ...f, name: e.target.value }))}\n        placeholder=\"Name\"\n      />\n      <input\n        value={form.email}\n        onChange={e => setForm(f => ({ ...f, email: e.target.value }))}\n        placeholder=\"Email\"\n      />\n      <input\n        type=\"password\"\n        value={form.password}\n        onChange={e => setForm(f => ({ ...f, password: e.target.value }))}\n        placeholder=\"Password\"\n      />\n\n      {errors.length > 0 && (\n        <ul style={{ color: 'red' }}>\n          {errors.map((err, i) => <li key={i}>{err}</li>)}\n        </ul>\n      )}\n\n      <button type=\"submit\">Sign Up</bu",
  "tags": [
    "typescript",
    "react",
    "node",
    "api",
    "ai",
    "seo"
  ],
  "useCases": [
    "When building React apps with fp-ts for type-safe state management",
    "When handling loading/error/success states in data fetching",
    "When implementing form validation with error accumulation",
    "When using React 18/19 or Next.js 14/15 with functional patterns"
  ],
  "scrapedAt": "2026-01-31T06:52:13.192Z"
}