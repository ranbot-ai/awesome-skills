{
  "id": "antigravity-langgraph",
  "name": "langgraph",
  "slug": "langgraph",
  "description": "Expert in LangGraph - the production-grade framework for building stateful, multi-actor AI applications. Covers graph construction, state management, cycles and branches, persistence with checkpointers, human-in-the-loop patterns, and the ReAct agent pattern. Used in production at LinkedIn, Uber, an",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/langgraph",
  "content": "\n# LangGraph\n\n**Role**: LangGraph Agent Architect\n\nYou are an expert in building production-grade AI agents with LangGraph. You\nunderstand that agents need explicit structure - graphs make the flow visible\nand debuggable. You design state carefully, use reducers appropriately, and\nalways consider persistence for production. You know when cycles are needed\nand how to prevent infinite loops.\n\n## Capabilities\n\n- Graph construction (StateGraph)\n- State management and reducers\n- Node and edge definitions\n- Conditional routing\n- Checkpointers and persistence\n- Human-in-the-loop patterns\n- Tool integration\n- Streaming and async execution\n\n## Requirements\n\n- Python 3.9+\n- langgraph package\n- LLM API access (OpenAI, Anthropic, etc.)\n- Understanding of graph concepts\n\n## Patterns\n\n### Basic Agent Graph\n\nSimple ReAct-style agent with tools\n\n**When to use**: Single agent with tool calling\n\n```python\nfrom typing import Annotated, TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.graph.message import add_messages\nfrom langgraph.prebuilt import ToolNode\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.tools import tool\n\n# 1. Define State\nclass AgentState(TypedDict):\n    messages: Annotated[list, add_messages]\n    # add_messages reducer appends, doesn't overwrite\n\n# 2. Define Tools\n@tool\ndef search(query: str) -> str:\n    \"\"\"Search the web for information.\"\"\"\n    # Implementation here\n    return f\"Results for: {query}\"\n\n@tool\ndef calculator(expression: str) -> str:\n    \"\"\"Evaluate a math expression.\"\"\"\n    return str(eval(expression))\n\ntools = [search, calculator]\n\n# 3. Create LLM with tools\nllm = ChatOpenAI(model=\"gpt-4o\").bind_tools(tools)\n\n# 4. Define Nodes\ndef agent(state: AgentState) -> dict:\n    \"\"\"The agent node - calls LLM.\"\"\"\n    response = llm.invoke(state[\"messages\"])\n    return {\"messages\": [response]}\n\n# Tool node handles tool execution\ntool_node = ToolNode(tools)\n\n# 5. Define Routing\ndef should_continue(state: AgentState) -> str:\n    \"\"\"Route based on whether tools were called.\"\"\"\n    last_message = state[\"messages\"][-1]\n    if last_message.tool_calls:\n        return \"tools\"\n    return END\n\n# 6. Build Graph\ngraph = StateGraph(AgentState)\n\n# Add nodes\ngraph.add_node(\"agent\", agent)\ngraph.add_node(\"tools\", tool_node)\n\n# Add edges\ngraph.add_edge(START, \"agent\")\ngraph.add_conditional_edges(\"agent\", should_continue, [\"tools\", END])\ngraph.add_edge(\"tools\", \"agent\")  # Loop back\n\n# Compile\napp = graph.compile()\n\n# 7. Run\nresult = app.invoke({\n    \"messages\": [(\"user\", \"What is 25 * 4?\")]\n})\n```\n\n### State with Reducers\n\nComplex state management with custom reducers\n\n**When to use**: Multiple agents updating shared state\n\n```python\nfrom typing import Annotated, TypedDict\nfrom operator import add\nfrom langgraph.graph import StateGraph\n\n# Custom reducer for merging dictionaries\ndef merge_dicts(left: dict, right: dict) -> dict:\n    return {**left, **right}\n\n# State with multiple reducers\nclass ResearchState(TypedDict):\n    # Messages append (don't overwrite)\n    messages: Annotated[list, add_messages]\n\n    # Research findings merge\n    findings: Annotated[dict, merge_dicts]\n\n    # Sources accumulate\n    sources: Annotated[list[str], add]\n\n    # Current step (overwrites - no reducer)\n    current_step: str\n\n    # Error count (custom reducer)\n    errors: Annotated[int, lambda a, b: a + b]\n\n# Nodes return partial state updates\ndef researcher(state: ResearchState) -> dict:\n    # Only return fields being updated\n    return {\n        \"findings\": {\"topic_a\": \"New finding\"},\n        \"sources\": [\"source1.com\"],\n        \"current_step\": \"researching\"\n    }\n\ndef writer(state: ResearchState) -> dict:\n    # Access accumulated state\n    all_findings = state[\"findings\"]\n    all_sources = state[\"sources\"]\n\n    return {\n        \"messages\": [(\"assistant\", f\"Report based on {len(all_sources)} sources\")],\n        \"current_step\": \"writing\"\n    }\n\n# Build graph\ngraph = StateGraph(ResearchState)\ngraph.add_node(\"researcher\", researcher)\ngraph.add_node(\"writer\", writer)\n# ... add edges\n```\n\n### Conditional Branching\n\nRoute to different paths based on state\n\n**When to use**: Multiple possible workflows\n\n```python\nfrom langgraph.graph import StateGraph, START, END\n\nclass RouterState(TypedDict):\n    query: str\n    query_type: str\n    result: str\n\ndef classifier(state: RouterState) -> dict:\n    \"\"\"Classify the query type.\"\"\"\n    query = state[\"query\"].lower()\n    if \"code\" in query or \"program\" in query:\n        return {\"query_type\": \"coding\"}\n    elif \"search\" in query or \"find\" in query:\n        return {\"query_type\": \"search\"}\n    else:\n        return {\"query_type\": \"chat\"}\n\ndef coding_agent(state: RouterState) -> dict:\n    return {\"result\": \"Here's your code...\"}\n\ndef search_agent(state: RouterState) -> dict:\n    return {\"result\": \"Search results...\"}\n\ndef chat_agent(state: RouterState) -> dict:\n    return {\"result\": \"Let me help...\"}\n\n# Routing function\ndef route_query(state: RouterState) -> str:\n    \"\"\"Route ",
  "tags": [
    "python",
    "typescript",
    "react",
    "node",
    "api",
    "ai",
    "agent",
    "llm",
    "gpt",
    "workflow"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-26T13:19:12.698Z"
}