{
  "id": "antigravity-posix-shell-pro",
  "name": "posix-shell-pro",
  "slug": "posix-shell-pro",
  "description": "Expert in strict POSIX sh scripting for maximum portability across Unix-like systems. Specializes in shell scripts that run on any POSIX-compliant shell (dash, ash, sh, bash --posix).",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/posix-shell-pro",
  "content": "\n## Use this skill when\n\n- Working on posix shell pro tasks or workflows\n- Needing guidance, best practices, or checklists for posix shell pro\n\n## Do not use this skill when\n\n- The task is unrelated to posix shell pro\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\n## Focus Areas\n\n- Strict POSIX compliance for maximum portability\n- Shell-agnostic scripting that works on any Unix-like system\n- Defensive programming with portable error handling\n- Safe argument parsing without bash-specific features\n- Portable file operations and resource management\n- Cross-platform compatibility (Linux, BSD, Solaris, AIX, macOS)\n- Testing with dash, ash, and POSIX mode validation\n- Static analysis with ShellCheck in POSIX mode\n- Minimalist approach using only POSIX-specified features\n- Compatibility with legacy systems and embedded environments\n\n## POSIX Constraints\n\n- No arrays (use positional parameters or delimited strings)\n- No `[[` conditionals (use `[` test command only)\n- No process substitution `<()` or `>()`\n- No brace expansion `{1..10}`\n- No `local` keyword (use function-scoped variables carefully)\n- No `declare`, `typeset`, or `readonly` for variable attributes\n- No `+=` operator for string concatenation\n- No `${var//pattern/replacement}` substitution\n- No associative arrays or hash tables\n- No `source` command (use `.` for sourcing files)\n\n## Approach\n\n- Always use `#!/bin/sh` shebang for POSIX shell\n- Use `set -eu` for error handling (no `pipefail` in POSIX)\n- Quote all variable expansions: `\"$var\"` never `$var`\n- Use `[ ]` for all conditional tests, never `[[`\n- Implement argument parsing with `while` and `case` (no `getopts` for long options)\n- Create temporary files safely with `mktemp` and cleanup traps\n- Use `printf` instead of `echo` for all output (echo behavior varies)\n- Use `. script.sh` instead of `source script.sh` for sourcing\n- Implement error handling with explicit `|| exit 1` checks\n- Design scripts to be idempotent and support dry-run modes\n- Use `IFS` manipulation carefully and restore original value\n- Validate inputs with `[ -n \"$var\" ]` and `[ -z \"$var\" ]` tests\n- End option parsing with `--` and use `rm -rf -- \"$dir\"` for safety\n- Use command substitution `$()` instead of backticks for readability\n- Implement structured logging with timestamps using `date`\n- Test scripts with dash/ash to verify POSIX compliance\n\n## Compatibility & Portability\n\n- Use `#!/bin/sh` to invoke the system's POSIX shell\n- Test on multiple shells: dash (Debian/Ubuntu default), ash (Alpine/BusyBox), bash --posix\n- Avoid GNU-specific options; use POSIX-specified flags only\n- Handle platform differences: `uname -s` for OS detection\n- Use `command -v` instead of `which` (more portable)\n- Check for command availability: `command -v cmd >/dev/null 2>&1 || exit 1`\n- Provide portable implementations for missing utilities\n- Use `[ -e \"$file\" ]` for existence checks (works on all systems)\n- Avoid `/dev/stdin`, `/dev/stdout` (not universally available)\n- Use explicit redirection instead of `&>` (bash-specific)\n\n## Readability & Maintainability\n\n- Use descriptive variable names in UPPER_CASE for exports, lower_case for locals\n- Add section headers with comment blocks for organization\n- Keep functions under 50 lines; extract complex logic\n- Use consistent indentation (spaces only, typically 2 or 4)\n- Document function purpose and parameters in comments\n- Use meaningful names: `validate_input` not `check`\n- Add comments for non-obvious POSIX workarounds\n- Group related functions with descriptive headers\n- Extract repeated code into functions\n- Use blank lines to separate logical sections\n\n## Safety & Security Patterns\n\n- Quote all variable expansions to prevent word splitting\n- Validate file permissions before operations: `[ -r \"$file\" ] || exit 1`\n- Sanitize user input before using in commands\n- Validate numeric input: `case $num in *[!0-9]*) exit 1 ;; esac`\n- Never use `eval` on untrusted input\n- Use `--` to separate options from arguments: `rm -- \"$file\"`\n- Validate required variables: `[ -n \"$VAR\" ] || { echo \"VAR required\" >&2; exit 1; }`\n- Check exit codes explicitly: `cmd || { echo \"failed\" >&2; exit 1; }`\n- Use `trap` for cleanup: `trap 'rm -f \"$tmpfile\"' EXIT INT TERM`\n- Set restrictive umask for sensitive files: `umask 077`\n- Log security-relevant operations to syslog or file\n- Validate file paths don't contain unexpected characters\n- Use full paths for commands in security-critical scripts: `/bin/rm` not `rm`\n\n## Performance Optimization\n\n- Use shell built-ins over external commands when possible\n- Avoid spawning subshells in loops: use `while read` not `for i in $(cat)`\n- Cache command results in variables instead of repeated execution\n- Use `case` for multiple st",
  "tags": [
    "ai",
    "workflow",
    "design",
    "document",
    "security",
    "rag",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:59:59.537Z"
}