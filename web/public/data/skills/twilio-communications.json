{
  "id": "antigravity-twilio-communications",
  "name": "twilio-communications",
  "slug": "twilio-communications",
  "description": "Build communication features with Twilio: SMS messaging, voice calls, WhatsApp Business API, and user verification (2FA). Covers the full spectrum from simple notifications to complex IVR systems and multi-channel authentication. Critical focus on compliance, rate limits, and error handling. Use whe",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/twilio-communications",
  "content": "\n# Twilio Communications\n\n## Patterns\n\n### SMS Sending Pattern\n\nBasic pattern for sending SMS messages with Twilio.\nHandles the fundamentals: phone number formatting, message delivery,\nand delivery status callbacks.\n\nKey considerations:\n- Phone numbers must be in E.164 format (+1234567890)\n- Default rate limit: 80 messages per second (MPS)\n- Messages over 160 characters are split (and cost more)\n- Carrier filtering can block messages (especially to US numbers)\n\n\n**When to use**: ['Sending notifications to users', 'Transactional messages (order confirmations, shipping)', 'Alerts and reminders']\n\n```python\nfrom twilio.rest import Client\nfrom twilio.base.exceptions import TwilioRestException\nimport os\nimport re\n\nclass TwilioSMS:\n    \"\"\"\n    SMS sending with proper error handling and validation.\n    \"\"\"\n\n    def __init__(self):\n        self.client = Client(\n            os.environ[\"TWILIO_ACCOUNT_SID\"],\n            os.environ[\"TWILIO_AUTH_TOKEN\"]\n        )\n        self.from_number = os.environ[\"TWILIO_PHONE_NUMBER\"]\n\n    def validate_e164(self, phone: str) -> bool:\n        \"\"\"Validate phone number is in E.164 format.\"\"\"\n        pattern = r'^\\+[1-9]\\d{1,14}$'\n        return bool(re.match(pattern, phone))\n\n    def send_sms(\n        self,\n        to: str,\n        body: str,\n        status_callback: str = None\n    ) -> dict:\n        \"\"\"\n        Send an SMS message.\n\n        Args:\n            to: Recipient phone number in E.164 format\n            body: Message text (160 chars = 1 segment)\n            status_callback: URL for delivery status webhooks\n\n        Returns:\n            Message SID and status\n        \"\"\"\n        # Validate phone number format\n        if not self.validate_e164(to):\n            return {\n                \"success\": False,\n                \"error\": \"Phone number must be in E.164 format (+1234567890)\"\n            }\n\n        # Check message length (warn about segmentation)\n        segment_count = (len(body) + 159) // 160\n        if segment_count > 1:\n            print(f\"Warning: Message will be sent as {segment_count} segments\")\n\n        try:\n            message = self.client.messages.create(\n                to=to,\n                from_=self.from_number,\n                body=body,\n                status_callback=status_callback\n            )\n\n            return {\n                \"success\": True,\n                \"message_sid\": message.sid,\n                \"status\": message.status,\n                \"segments\": segment_count\n            }\n\n        except TwilioRestException as e:\n            return self._handle_error(e)\n\n    def _handle_error(self, error: Twilio\n```\n\n### Twilio Verify Pattern (2FA/OTP)\n\nUse Twilio Verify for phone number verification and 2FA.\nHandles code generation, delivery, rate limiting, and fraud prevention.\n\nKey benefits over DIY OTP:\n- Twilio manages code generation and expiration\n- Built-in fraud prevention (saved customers $82M+ blocking 747M attempts)\n- Handles rate limiting automatically\n- Multi-channel: SMS, Voice, Email, Push, WhatsApp\n\nGoogle found SMS 2FA blocks \"100% of automated bots, 96% of bulk\nphishing attacks, and 76% of targeted attacks.\"\n\n\n**When to use**: ['User phone number verification at signup', 'Two-factor authentication (2FA)', 'Password reset verification', 'High-value transaction confirmation']\n\n```python\nfrom twilio.rest import Client\nfrom twilio.base.exceptions import TwilioRestException\nimport os\nfrom enum import Enum\nfrom typing import Optional\n\nclass VerifyChannel(Enum):\n    SMS = \"sms\"\n    CALL = \"call\"\n    EMAIL = \"email\"\n    WHATSAPP = \"whatsapp\"\n\nclass TwilioVerify:\n    \"\"\"\n    Phone verification with Twilio Verify.\n    Never store OTP codes - Twilio handles it.\n    \"\"\"\n\n    def __init__(self, verify_service_sid: str = None):\n        self.client = Client(\n            os.environ[\"TWILIO_ACCOUNT_SID\"],\n            os.environ[\"TWILIO_AUTH_TOKEN\"]\n        )\n        # Create a Verify Service in Twilio Console first\n        self.service_sid = verify_service_sid or os.environ[\"TWILIO_VERIFY_SID\"]\n\n    def send_verification(\n        self,\n        to: str,\n        channel: VerifyChannel = VerifyChannel.SMS,\n        locale: str = \"en\"\n    ) -> dict:\n        \"\"\"\n        Send verification code to phone/email.\n\n        Args:\n            to: Phone number (E.164) or email\n            channel: SMS, call, email, or whatsapp\n            locale: Language code for message\n\n        Returns:\n            Verification status\n        \"\"\"\n        try:\n            verification = self.client.verify \\\n                .v2 \\\n                .services(self.service_sid) \\\n                .verifications \\\n                .create(\n                    to=to,\n                    channel=channel.value,\n                    locale=locale\n                )\n\n            return {\n                \"success\": True,\n                \"status\": verification.status,  # \"pending\"\n                \"channel\": channel.value,\n                \"valid\": verification.valid\n            }\n\n        except Twi",
  "tags": [
    "python",
    "api",
    "ai"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-26T13:22:19.568Z"
}