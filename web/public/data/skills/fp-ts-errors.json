{
  "id": "antigravity-fp-ts-errors",
  "name": "fp-ts-errors",
  "slug": "fp-ts-errors",
  "description": "Handle errors as values using fp-ts Either and TaskEither for cleaner, more predictable TypeScript code. Use when implementing error handling patterns with fp-ts.",
  "category": "Business & Marketing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/fp-ts-errors",
  "content": "\n# Practical Error Handling with fp-ts\n\nThis skill teaches you how to handle errors without try/catch spaghetti. No academic jargon - just practical patterns for real problems.\n\n## When to Use This Skill\n\n- When you want type-safe error handling in TypeScript\n- When replacing try/catch with Either and TaskEither patterns\n- When building APIs or services that need explicit error types\n- When accumulating multiple validation errors\n\nThe core idea: **Errors are just data**. Instead of throwing them into the void and hoping someone catches them, return them as values that TypeScript can track.\n\n---\n\n## 1. Stop Throwing Everywhere\n\n### The Problem with Exceptions\n\nExceptions are invisible in your types. They break the contract between functions.\n\n```typescript\n// What this function signature promises:\nfunction getUser(id: string): User\n\n// What it actually does:\nfunction getUser(id: string): User {\n  if (!id) throw new Error('ID required')\n  const user = db.find(id)\n  if (!user) throw new Error('User not found')\n  return user\n}\n\n// The caller has no idea this can fail\nconst user = getUser(id) // Might explode!\n```\n\nYou end up with code like this:\n\n```typescript\n// MESSY: try/catch everywhere\nfunction processOrder(orderId: string) {\n  let order\n  try {\n    order = getOrder(orderId)\n  } catch (e) {\n    console.error('Failed to get order')\n    return null\n  }\n\n  let user\n  try {\n    user = getUser(order.userId)\n  } catch (e) {\n    console.error('Failed to get user')\n    return null\n  }\n\n  let payment\n  try {\n    payment = chargeCard(user.cardId, order.total)\n  } catch (e) {\n    console.error('Payment failed')\n    return null\n  }\n\n  return { order, user, payment }\n}\n```\n\n### The Solution: Return Errors as Values\n\n```typescript\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\n\n// Now TypeScript KNOWS this can fail\nfunction getUser(id: string): E.Either<string, User> {\n  if (!id) return E.left('ID required')\n  const user = db.find(id)\n  if (!user) return E.left('User not found')\n  return E.right(user)\n}\n\n// The caller is forced to handle both cases\nconst result = getUser(id)\n// result is Either<string, User> - error OR success, never both\n```\n\n---\n\n## 2. The Result Pattern (Either)\n\n`Either<E, A>` is simple: it holds either an error (`E`) or a value (`A`).\n\n- `Left` = error case\n- `Right` = success case (think \"right\" as in \"correct\")\n\n```typescript\nimport * as E from 'fp-ts/Either'\n\n// Creating values\nconst success = E.right(42)           // Right(42)\nconst failure = E.left('Oops')        // Left('Oops')\n\n// Checking what you have\nif (E.isRight(result)) {\n  console.log(result.right) // The success value\n} else {\n  console.log(result.left)  // The error\n}\n\n// Better: pattern match with fold\nconst message = pipe(\n  result,\n  E.fold(\n    (error) => `Failed: ${error}`,\n    (value) => `Got: ${value}`\n  )\n)\n```\n\n### Converting Throwing Code to Either\n\n```typescript\n// Wrap any throwing function with tryCatch\nconst parseJSON = (json: string): E.Either<Error, unknown> =>\n  E.tryCatch(\n    () => JSON.parse(json),\n    (e) => (e instanceof Error ? e : new Error(String(e)))\n  )\n\nparseJSON('{\"valid\": true}')  // Right({ valid: true })\nparseJSON('not json')          // Left(SyntaxError: ...)\n\n// For functions you'll reuse, use tryCatchK\nconst safeParseJSON = E.tryCatchK(\n  JSON.parse,\n  (e) => (e instanceof Error ? e : new Error(String(e)))\n)\n```\n\n### Common Either Operations\n\n```typescript\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\n\n// Transform the success value\nconst doubled = pipe(\n  E.right(21),\n  E.map(n => n * 2)\n) // Right(42)\n\n// Transform the error\nconst betterError = pipe(\n  E.left('bad'),\n  E.mapLeft(e => `Error: ${e}`)\n) // Left('Error: bad')\n\n// Provide a default for errors\nconst value = pipe(\n  E.left('failed'),\n  E.getOrElse(() => 0)\n) // 0\n\n// Convert nullable to Either\nconst fromNullable = E.fromNullable('not found')\nfromNullable(user)  // Right(user) if exists, Left('not found') if null/undefined\n```\n\n---\n\n## 3. Chaining Operations That Might Fail\n\nThe real power comes from chaining. Each step can fail, but you write it as a clean pipeline.\n\n### Before: Nested Try/Catch Hell\n\n```typescript\n// MESSY: Each step can fail, nested try/catch everywhere\nfunction processUserOrder(userId: string, productId: string): Result | null {\n  let user\n  try {\n    user = getUser(userId)\n  } catch (e) {\n    logError('User fetch failed', e)\n    return null\n  }\n\n  if (!user.isActive) {\n    logError('User not active')\n    return null\n  }\n\n  let product\n  try {\n    product = getProduct(productId)\n  } catch (e) {\n    logError('Product fetch failed', e)\n    return null\n  }\n\n  if (product.stock < 1) {\n    logError('Out of stock')\n    return null\n  }\n\n  let order\n  try {\n    order = createOrder(user, product)\n  } catch (e) {\n    logError('Order creation failed', e)\n    return null\n  }\n\n  return order\n}\n```\n\n### After: Clean Chain with Either\n\n```typescript\nimport * as E from 'fp-ts/Either",
  "tags": [
    "typescript",
    "api",
    "ai",
    "prisma"
  ],
  "useCases": [
    "When you want type-safe error handling in TypeScript",
    "When replacing try/catch with Either and TaskEither patterns",
    "When building APIs or services that need explicit error types",
    "When accumulating multiple validation errors"
  ],
  "scrapedAt": "2026-01-31T06:52:12.424Z"
}