{
  "id": "antigravity-fp-ts-pragmatic",
  "name": "fp-ts-pragmatic",
  "slug": "fp-ts-pragmatic",
  "description": "A practical, jargon-free guide to fp-ts functional programming - the 80/20 approach that gets results without the academic overhead. Use when writing TypeScript with fp-ts library.",
  "category": "Development & Code Tools",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/fp-ts-pragmatic",
  "content": "\n# Pragmatic Functional Programming\n\n**Read this first.** This guide cuts through the academic jargon and shows you what actually matters. No category theory. No abstract nonsense. Just patterns that make your code better.\n\n## When to Use This Skill\n\n- When starting with fp-ts and need practical guidance\n- When writing TypeScript code that handles nullable values, errors, or async operations\n- When you want cleaner, more maintainable functional code without the academic overhead\n- When refactoring imperative code to functional style\n\n## The Golden Rule\n\n> **If functional programming makes your code harder to read, don't use it.**\n\nFP is a tool, not a religion. Use it when it helps. Skip it when it doesn't.\n\n---\n\n## The 80/20 of FP\n\nThese five patterns give you most of the benefits. Master these before exploring anything else.\n\n### 1. Pipe: Chain Operations Clearly\n\nInstead of nesting function calls or creating intermediate variables, chain operations in reading order.\n\n```typescript\nimport { pipe } from 'fp-ts/function'\n\n// Before: Hard to read (inside-out)\nconst result = format(validate(parse(input)))\n\n// Before: Too many variables\nconst parsed = parse(input)\nconst validated = validate(parsed)\nconst result = format(validated)\n\n// After: Clear, linear flow\nconst result = pipe(\n  input,\n  parse,\n  validate,\n  format\n)\n```\n\n**When to use pipe:**\n- 3+ transformations on the same data\n- You find yourself naming throwaway variables\n- Logic reads better top-to-bottom\n\n**When to skip pipe:**\n- Just 1-2 operations (direct call is fine)\n- The operations don't naturally chain\n\n### 2. Option: Handle Missing Values Without null Checks\n\nStop writing `if (x !== null && x !== undefined)` everywhere.\n\n```typescript\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\n// Before: Defensive null checking\nfunction getUserCity(user: User | null): string {\n  if (user === null) return 'Unknown'\n  if (user.address === null) return 'Unknown'\n  if (user.address.city === null) return 'Unknown'\n  return user.address.city\n}\n\n// After: Chain through potential missing values\nconst getUserCity = (user: User | null): string =>\n  pipe(\n    O.fromNullable(user),\n    O.flatMap(u => O.fromNullable(u.address)),\n    O.flatMap(a => O.fromNullable(a.city)),\n    O.getOrElse(() => 'Unknown')\n  )\n```\n\n**Plain language translation:**\n- `O.fromNullable(x)` = \"wrap this value, treating null/undefined as 'nothing'\"\n- `O.flatMap(fn)` = \"if we have something, apply this function\"\n- `O.getOrElse(() => default)` = \"unwrap, or use this default if nothing\"\n\n### 3. Either: Make Errors Explicit\n\nStop throwing exceptions for expected failures. Return errors as values.\n\n```typescript\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\n\n// Before: Hidden failure mode\nfunction parseAge(input: string): number {\n  const age = parseInt(input, 10)\n  if (isNaN(age)) throw new Error('Invalid age')\n  if (age < 0) throw new Error('Age cannot be negative')\n  return age\n}\n\n// After: Errors are visible in the type\nfunction parseAge(input: string): E.Either<string, number> {\n  const age = parseInt(input, 10)\n  if (isNaN(age)) return E.left('Invalid age')\n  if (age < 0) return E.left('Age cannot be negative')\n  return E.right(age)\n}\n\n// Using it\nconst result = parseAge(userInput)\nif (E.isRight(result)) {\n  console.log(`Age is ${result.right}`)\n} else {\n  console.log(`Error: ${result.left}`)\n}\n```\n\n**Plain language translation:**\n- `E.right(value)` = \"success with this value\"\n- `E.left(error)` = \"failure with this error\"\n- `E.isRight(x)` = \"did it succeed?\"\n\n### 4. Map: Transform Without Unpacking\n\nTransform values inside containers without extracting them first.\n\n```typescript\nimport * as O from 'fp-ts/Option'\nimport * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\n\n// Transform inside Option\nconst maybeUser: O.Option<User> = O.some({ name: 'Alice', age: 30 })\nconst maybeName: O.Option<string> = pipe(\n  maybeUser,\n  O.map(user => user.name)\n)\n\n// Transform inside Either\nconst result: E.Either<Error, number> = E.right(5)\nconst doubled: E.Either<Error, number> = pipe(\n  result,\n  E.map(n => n * 2)\n)\n\n// Transform arrays (same concept!)\nconst numbers = [1, 2, 3]\nconst doubled = pipe(\n  numbers,\n  A.map(n => n * 2)\n)\n```\n\n### 5. FlatMap: Chain Operations That Might Fail\n\nWhen each step might fail, chain them together.\n\n```typescript\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\n\nconst parseJSON = (s: string): E.Either<string, unknown> =>\n  E.tryCatch(() => JSON.parse(s), () => 'Invalid JSON')\n\nconst extractEmail = (data: unknown): E.Either<string, string> => {\n  if (typeof data === 'object' && data !== null && 'email' in data) {\n    return E.right((data as { email: string }).email)\n  }\n  return E.left('No email field')\n}\n\nconst validateEmail = (email: string): E.Either<string, string> =>\n  email.includes('@') ? E.right(email) : E.left('Invalid email format')\n\n// Chain a",
  "tags": [
    "typescript",
    "api",
    "ai",
    "rag"
  ],
  "useCases": [
    "When starting with fp-ts and need practical guidance",
    "When writing TypeScript code that handles nullable values, errors, or async operations",
    "When you want cleaner, more maintainable functional code without the academic overhead",
    "When refactoring imperative code to functional style"
  ],
  "scrapedAt": "2026-01-31T06:52:12.823Z"
}