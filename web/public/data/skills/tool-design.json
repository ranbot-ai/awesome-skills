{
  "id": "antigravity-tool-design",
  "name": "tool-design",
  "slug": "tool-design",
  "description": "Build tools that agents can use effectively, including architectural reduction patterns",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/tool-design",
  "content": "\n## When to Use This Skill\n\nBuild tools that agents can use effectively, including architectural reduction patterns\n\nUse this skill when working with build tools that agents can use effectively, including architectural reduction patterns.\n# Tool Design for Agents\n\nTools are the primary mechanism through which agents interact with the world. They define the contract between deterministic systems and non-deterministic agents. Unlike traditional software APIs designed for developers, tool APIs must be designed for language models that reason about intent, infer parameter values, and generate calls from natural language requests. Poor tool design creates failure modes that no amount of prompt engineering can fix. Effective tool design follows specific principles that account for how agents perceive and use tools.\n\n## When to Activate\n\nActivate this skill when:\n- Creating new tools for agent systems\n- Debugging tool-related failures or misuse\n- Optimizing existing tool sets for better agent performance\n- Designing tool APIs from scratch\n- Evaluating third-party tools for agent integration\n- Standardizing tool conventions across a codebase\n\n## Core Concepts\n\nTools are contracts between deterministic systems and non-deterministic agents. The consolidation principle states that if a human engineer cannot definitively say which tool should be used in a given situation, an agent cannot be expected to do better. Effective tool descriptions are prompt engineering that shapes agent behavior.\n\nKey principles include: clear descriptions that answer what, when, and what returns; response formats that balance completeness and token efficiency; error messages that enable recovery; and consistent conventions that reduce cognitive load.\n\n## Detailed Topics\n\n### The Tool-Agent Interface\n\n**Tools as Contracts**\nTools are contracts between deterministic systems and non-deterministic agents. When humans call APIs, they understand the contract and make appropriate requests. Agents must infer the contract from descriptions and generate calls that match expected formats.\n\nThis fundamental difference requires rethinking API design. The contract must be unambiguous, examples must illustrate expected patterns, and error messages must guide correction. Every ambiguity in tool definitions becomes a potential failure mode.\n\n**Tool Description as Prompt**\nTool descriptions are loaded into agent context and collectively steer behavior. The descriptions are not just documentationâ€”they are prompt engineering that shapes how agents reason about tool use.\n\nPoor descriptions like \"Search the database\" with cryptic parameter names force agents to guess. Optimized descriptions include usage context, examples, and defaults. The description answers: what the tool does, when to use it, and what it produces.\n\n**Namespacing and Organization**\nAs tool collections grow, organization becomes critical. Namespacing groups related tools under common prefixes, helping agents select appropriate tools at the right time.\n\nNamespacing creates clear boundaries between functionality. When an agent needs database information, it routes to the database namespace. When it needs web search, it routes to web namespace.\n\n### The Consolidation Principle\n\n**Single Comprehensive Tools**\nThe consolidation principle states that if a human engineer cannot definitively say which tool should be used in a given situation, an agent cannot be expected to do better. This leads to a preference for single comprehensive tools over multiple narrow tools.\n\nInstead of implementing list_users, list_events, and create_event, implement schedule_event that finds availability and schedules. The comprehensive tool handles the full workflow internally rather than requiring agents to chain multiple calls.\n\n**Why Consolidation Works**\nAgents have limited context and attention. Each tool in the collection competes for attention in the tool selection phase. Each tool adds description tokens that consume context budget. Overlapping functionality creates ambiguity about which tool to use.\n\nConsolidation reduces token consumption by eliminating redundant descriptions. It eliminates ambiguity by having one tool cover each workflow. It reduces tool selection complexity by shrinking the effective tool set.\n\n**When Not to Consolidate**\nConsolidation is not universally correct. Tools with fundamentally different behaviors should remain separate. Tools used in different contexts benefit from separation. Tools that might be called independently should not be artificially bundled.\n\n### Architectural Reduction\n\nThe consolidation principle, taken to its logical extreme, leads to architectural reduction: removing most specialized tools in favor of primitive, general-purpose capabilities. Production evidence shows this approach can outperform sophisticated multi-tool architectures.\n\n**The File System Agent Pattern**\nInstead of building custom tools for data exploration, schema lookup, and query validation, provide ",
  "tags": [
    "python",
    "api",
    "mcp",
    "claude",
    "ai",
    "agent",
    "workflow",
    "design",
    "document",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-31T06:54:43.895Z"
}