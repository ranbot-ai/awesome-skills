{
  "id": "antigravity-prompt-engineering-patterns",
  "name": "prompt-engineering-patterns",
  "slug": "prompt-engineering-patterns",
  "description": "Master advanced prompt engineering techniques to maximize LLM performance, reliability, and controllability in production. Use when optimizing prompts, improving LLM outputs, or designing production prompt templates.",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/prompt-engineering-patterns",
  "content": "\n# Prompt Engineering Patterns\n\nMaster advanced prompt engineering techniques to maximize LLM performance, reliability, and controllability.\n\n## Do not use this skill when\n\n- The task is unrelated to prompt engineering patterns\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\n## Use this skill when\n\n- Designing complex prompts for production LLM applications\n- Optimizing prompt performance and consistency\n- Implementing structured reasoning patterns (chain-of-thought, tree-of-thought)\n- Building few-shot learning systems with dynamic example selection\n- Creating reusable prompt templates with variable interpolation\n- Debugging and refining prompts that produce inconsistent outputs\n- Implementing system prompts for specialized AI assistants\n\n## Core Capabilities\n\n### 1. Few-Shot Learning\n- Example selection strategies (semantic similarity, diversity sampling)\n- Balancing example count with context window constraints\n- Constructing effective demonstrations with input-output pairs\n- Dynamic example retrieval from knowledge bases\n- Handling edge cases through strategic example selection\n\n### 2. Chain-of-Thought Prompting\n- Step-by-step reasoning elicitation\n- Zero-shot CoT with \"Let's think step by step\"\n- Few-shot CoT with reasoning traces\n- Self-consistency techniques (sampling multiple reasoning paths)\n- Verification and validation steps\n\n### 3. Prompt Optimization\n- Iterative refinement workflows\n- A/B testing prompt variations\n- Measuring prompt performance metrics (accuracy, consistency, latency)\n- Reducing token usage while maintaining quality\n- Handling edge cases and failure modes\n\n### 4. Template Systems\n- Variable interpolation and formatting\n- Conditional prompt sections\n- Multi-turn conversation templates\n- Role-based prompt composition\n- Modular prompt components\n\n### 5. System Prompt Design\n- Setting model behavior and constraints\n- Defining output formats and structure\n- Establishing role and expertise\n- Safety guidelines and content policies\n- Context setting and background information\n\n## Quick Start\n\n```python\nfrom prompt_optimizer import PromptTemplate, FewShotSelector\n\n# Define a structured prompt template\ntemplate = PromptTemplate(\n    system=\"You are an expert SQL developer. Generate efficient, secure SQL queries.\",\n    instruction=\"Convert the following natural language query to SQL:\\n{query}\",\n    few_shot_examples=True,\n    output_format=\"SQL code block with explanatory comments\"\n)\n\n# Configure few-shot learning\nselector = FewShotSelector(\n    examples_db=\"sql_examples.jsonl\",\n    selection_strategy=\"semantic_similarity\",\n    max_examples=3\n)\n\n# Generate optimized prompt\nprompt = template.render(\n    query=\"Find all users who registered in the last 30 days\",\n    examples=selector.select(query=\"user registration date filter\")\n)\n```\n\n## Key Patterns\n\n### Progressive Disclosure\nStart with simple prompts, add complexity only when needed:\n\n1. **Level 1**: Direct instruction\n   - \"Summarize this article\"\n\n2. **Level 2**: Add constraints\n   - \"Summarize this article in 3 bullet points, focusing on key findings\"\n\n3. **Level 3**: Add reasoning\n   - \"Read this article, identify the main findings, then summarize in 3 bullet points\"\n\n4. **Level 4**: Add examples\n   - Include 2-3 example summaries with input-output pairs\n\n### Instruction Hierarchy\n```\n[System Context] → [Task Instruction] → [Examples] → [Input Data] → [Output Format]\n```\n\n### Error Recovery\nBuild prompts that gracefully handle failures:\n- Include fallback instructions\n- Request confidence scores\n- Ask for alternative interpretations when uncertain\n- Specify how to indicate missing information\n\n## Best Practices\n\n1. **Be Specific**: Vague prompts produce inconsistent results\n2. **Show, Don't Tell**: Examples are more effective than descriptions\n3. **Test Extensively**: Evaluate on diverse, representative inputs\n4. **Iterate Rapidly**: Small changes can have large impacts\n5. **Monitor Performance**: Track metrics in production\n6. **Version Control**: Treat prompts as code with proper versioning\n7. **Document Intent**: Explain why prompts are structured as they are\n\n## Common Pitfalls\n\n- **Over-engineering**: Starting with complex prompts before trying simple ones\n- **Example pollution**: Using examples that don't match the target task\n- **Context overflow**: Exceeding token limits with excessive examples\n- **Ambiguous instructions**: Leaving room for multiple interpretations\n- **Ignoring edge cases**: Not testing on unusual or boundary inputs\n\n## Integration Patterns\n\n### With RAG Systems\n```python\n# Combine retrieved context with prompt engineering\nprompt = f\"\"\"Given the following context:\n{retrieved_context}\n\n{few_shot_examples}\n\nQuestion: {user_question}\n\nProvide a detailed a",
  "tags": [
    "python",
    "api",
    "ai",
    "llm",
    "workflow",
    "template",
    "design",
    "document",
    "rag",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:00:05.501Z"
}