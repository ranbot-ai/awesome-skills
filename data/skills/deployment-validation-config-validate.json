{
  "id": "antigravity-deployment-validation-config-validate",
  "name": "deployment-validation-config-validate",
  "slug": "deployment-validation-config-validate",
  "description": "You are a configuration management expert specializing in validating, testing, and ensuring the correctness of application configurations. Create comprehensive validation schemas, implement configurat",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/deployment-validation-config-validate",
  "content": "\n# Configuration Validation\n\nYou are a configuration management expert specializing in validating, testing, and ensuring the correctness of application configurations. Create comprehensive validation schemas, implement configuration testing strategies, and ensure configurations are secure, consistent, and error-free across all environments.\n\n## Use this skill when\n\n- Working on configuration validation tasks or workflows\n- Needing guidance, best practices, or checklists for configuration validation\n\n## Do not use this skill when\n\n- The task is unrelated to configuration validation\n- You need a different domain or tool outside this scope\n\n## Context\nThe user needs to validate configuration files, implement configuration schemas, ensure consistency across environments, and prevent configuration-related errors. Focus on creating robust validation rules, type safety, security checks, and automated validation processes.\n\n## Requirements\n$ARGUMENTS\n\n## Instructions\n\n### 1. Configuration Analysis\n\nAnalyze existing configuration structure and identify validation needs:\n\n```python\nimport os\nimport yaml\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Any\n\nclass ConfigurationAnalyzer:\n    def analyze_project(self, project_path: str) -> Dict[str, Any]:\n        analysis = {\n            'config_files': self._find_config_files(project_path),\n            'security_issues': self._check_security_issues(project_path),\n            'consistency_issues': self._check_consistency(project_path),\n            'recommendations': []\n        }\n        return analysis\n\n    def _find_config_files(self, project_path: str) -> List[Dict]:\n        config_patterns = [\n            '**/*.json', '**/*.yaml', '**/*.yml', '**/*.toml',\n            '**/*.ini', '**/*.env*', '**/config.js'\n        ]\n\n        config_files = []\n        for pattern in config_patterns:\n            for file_path in Path(project_path).glob(pattern):\n                if not self._should_ignore(file_path):\n                    config_files.append({\n                        'path': str(file_path),\n                        'type': self._detect_config_type(file_path),\n                        'environment': self._detect_environment(file_path)\n                    })\n        return config_files\n\n    def _check_security_issues(self, project_path: str) -> List[Dict]:\n        issues = []\n        secret_patterns = [\n            r'(api[_-]?key|apikey)',\n            r'(secret|password|passwd)',\n            r'(token|auth)',\n            r'(aws[_-]?access)'\n        ]\n\n        for config_file in self._find_config_files(project_path):\n            content = Path(config_file['path']).read_text()\n            for pattern in secret_patterns:\n                if re.search(pattern, content, re.IGNORECASE):\n                    if self._looks_like_real_secret(content, pattern):\n                        issues.append({\n                            'file': config_file['path'],\n                            'type': 'potential_secret',\n                            'severity': 'high'\n                        })\n        return issues\n```\n\n### 2. Schema Validation\n\nImplement configuration schema validation with JSON Schema:\n\n```typescript\nimport Ajv from 'ajv';\nimport ajvFormats from 'ajv-formats';\nimport { JSONSchema7 } from 'json-schema';\n\ninterface ValidationResult {\n  valid: boolean;\n  errors?: Array<{\n    path: string;\n    message: string;\n    keyword: string;\n  }>;\n}\n\nexport class ConfigValidator {\n  private ajv: Ajv;\n\n  constructor() {\n    this.ajv = new Ajv({\n      allErrors: true,\n      strict: false,\n      coerceTypes: true\n    });\n    ajvFormats(this.ajv);\n    this.addCustomFormats();\n  }\n\n  private addCustomFormats() {\n    this.ajv.addFormat('url-https', {\n      type: 'string',\n      validate: (data: string) => {\n        try {\n          return new URL(data).protocol === 'https:';\n        } catch { return false; }\n      }\n    });\n\n    this.ajv.addFormat('port', {\n      type: 'number',\n      validate: (data: number) => data >= 1 && data <= 65535\n    });\n\n    this.ajv.addFormat('duration', {\n      type: 'string',\n      validate: /^\\d+[smhd]$/\n    });\n  }\n\n  validate(configData: any, schemaName: string): ValidationResult {\n    const validate = this.ajv.getSchema(schemaName);\n    if (!validate) throw new Error(`Schema '${schemaName}' not found`);\n\n    const valid = validate(configData);\n\n    if (!valid && validate.errors) {\n      return {\n        valid: false,\n        errors: validate.errors.map(error => ({\n          path: error.instancePath || '/',\n          message: error.message || 'Validation error',\n          keyword: error.keyword\n        }))\n      };\n    }\n    return { valid: true };\n  }\n}\n\n// Example schema\nexport const schemas = {\n  database: {\n    type: 'object',\n    properties: {\n      host: { type: 'string', format: 'hostname' },\n      port: { type: 'integer', format: 'port' },\n      database: { type: 'string', minLength: 1 },\n      user: { type: 'string', minLength: 1 },\n      pas",
  "tags": [
    "python",
    "typescript",
    "api",
    "ai",
    "workflow",
    "document",
    "security",
    "aws",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:58:45.385Z"
}