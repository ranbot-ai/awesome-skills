{
  "id": "antigravity-backend-development-feature-development",
  "name": "backend-development-feature-development",
  "slug": "backend-development-feature-development",
  "description": "Orchestrate end-to-end backend feature development from requirements to deployment. Use when coordinating multi-phase feature delivery across teams and services.",
  "category": "Security & Systems",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/backend-development-feature-development",
  "content": "\nOrchestrate end-to-end feature development from requirements to production deployment:\n\n[Extended thinking: This workflow orchestrates specialized agents through comprehensive feature development phases - from discovery and planning through implementation, testing, and deployment. Each phase builds on previous outputs, ensuring coherent feature delivery. The workflow supports multiple development methodologies (traditional, TDD/BDD, DDD), feature complexity levels, and modern deployment strategies including feature flags, gradual rollouts, and observability-first development. Agents receive detailed context from previous phases to maintain consistency and quality throughout the development lifecycle.]\n\n## Use this skill when\n\n- Coordinating end-to-end feature delivery across backend, frontend, and data\n- Managing requirements, architecture, implementation, testing, and rollout\n- Planning multi-service changes with deployment and monitoring needs\n- Aligning teams on scope, risks, and success metrics\n\n## Do not use this skill when\n\n- The task is a small, isolated backend change or bug fix\n- You only need a single specialist task, not a full workflow\n- There is no deployment or cross-team coordination involved\n\n## Instructions\n\n1. Confirm feature scope, success metrics, and constraints.\n2. Select a methodology and define phase outputs.\n3. Orchestrate implementation, testing, and security validation.\n4. Prepare rollout, monitoring, and documentation plans.\n\n## Safety\n\n- Avoid production changes without approvals and rollback plans.\n- Validate data migrations and feature flags in staging first.\n\n## Configuration Options\n\n### Development Methodology\n\n- **traditional**: Sequential development with testing after implementation\n- **tdd**: Test-Driven Development with red-green-refactor cycles\n- **bdd**: Behavior-Driven Development with scenario-based testing\n- **ddd**: Domain-Driven Design with bounded contexts and aggregates\n\n### Feature Complexity\n\n- **simple**: Single service, minimal integration (1-2 days)\n- **medium**: Multiple services, moderate integration (3-5 days)\n- **complex**: Cross-domain, extensive integration (1-2 weeks)\n- **epic**: Major architectural changes, multiple teams (2+ weeks)\n\n### Deployment Strategy\n\n- **direct**: Immediate rollout to all users\n- **canary**: Gradual rollout starting with 5% of traffic\n- **feature-flag**: Controlled activation via feature toggles\n- **blue-green**: Zero-downtime deployment with instant rollback\n- **a-b-test**: Split traffic for experimentation and metrics\n\n## Phase 1: Discovery & Requirements Planning\n\n1. **Business Analysis & Requirements**\n   - Use Task tool with subagent_type=\"business-analytics::business-analyst\"\n   - Prompt: \"Analyze feature requirements for: $ARGUMENTS. Define user stories, acceptance criteria, success metrics, and business value. Identify stakeholders, dependencies, and risks. Create feature specification document with clear scope boundaries.\"\n   - Expected output: Requirements document with user stories, success metrics, risk assessment\n   - Context: Initial feature request and business context\n\n2. **Technical Architecture Design**\n   - Use Task tool with subagent_type=\"comprehensive-review::architect-review\"\n   - Prompt: \"Design technical architecture for feature: $ARGUMENTS. Using requirements: [include business analysis from step 1]. Define service boundaries, API contracts, data models, integration points, and technology stack. Consider scalability, performance, and security requirements.\"\n   - Expected output: Technical design document with architecture diagrams, API specifications, data models\n   - Context: Business requirements, existing system architecture\n\n3. **Feasibility & Risk Assessment**\n   - Use Task tool with subagent_type=\"security-scanning::security-auditor\"\n   - Prompt: \"Assess security implications and risks for feature: $ARGUMENTS. Review architecture: [include technical design from step 2]. Identify security requirements, compliance needs, data privacy concerns, and potential vulnerabilities.\"\n   - Expected output: Security assessment with risk matrix, compliance checklist, mitigation strategies\n   - Context: Technical design, regulatory requirements\n\n## Phase 2: Implementation & Development\n\n4. **Backend Services Implementation**\n   - Use Task tool with subagent_type=\"backend-architect\"\n   - Prompt: \"Implement backend services for: $ARGUMENTS. Follow technical design: [include architecture from step 2]. Build RESTful/GraphQL APIs, implement business logic, integrate with data layer, add resilience patterns (circuit breakers, retries), implement caching strategies. Include feature flags for gradual rollout.\"\n   - Expected output: Backend services with APIs, business logic, database integration, feature flags\n   - Context: Technical design, API contracts, data models\n\n5. **Frontend Implementation**\n   - Use Task tool with subagent_type=\"frontend-mobile-development::frontend-developer\"\n   - Prompt: \"Build fronten",
  "tags": [
    "api",
    "ai",
    "agent",
    "workflow",
    "design",
    "document",
    "security",
    "vulnerability",
    "rag",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:58:06.758Z"
}