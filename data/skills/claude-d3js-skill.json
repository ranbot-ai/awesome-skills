{
  "id": "antigravity-claude-d3js-skill",
  "name": "d3-viz",
  "slug": "claude-d3js-skill",
  "description": "Creating interactive data visualisations using d3.js. This skill should be used when creating custom charts, graphs, network diagrams, geographic visualisations, or any complex SVG-based data visualisation that requires fine-grained control over visual elements, transitions, or interactions. Use thi",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/claude-d3js-skill",
  "content": "\n# D3.js Visualisation\n\n## Overview\n\nThis skill provides guidance for creating sophisticated, interactive data visualisations using d3.js. D3.js (Data-Driven Documents) excels at binding data to DOM elements and applying data-driven transformations to create custom, publication-quality visualisations with precise control over every visual element. The techniques work across any JavaScript environment, including vanilla JavaScript, React, Vue, Svelte, and other frameworks.\n\n## When to use d3.js\n\n**Use d3.js for:**\n- Custom visualisations requiring unique visual encodings or layouts\n- Interactive explorations with complex pan, zoom, or brush behaviours\n- Network/graph visualisations (force-directed layouts, tree diagrams, hierarchies, chord diagrams)\n- Geographic visualisations with custom projections\n- Visualisations requiring smooth, choreographed transitions\n- Publication-quality graphics with fine-grained styling control\n- Novel chart types not available in standard libraries\n\n**Consider alternatives for:**\n- 3D visualisations - use Three.js instead\n\n## Core workflow\n\n### 1. Set up d3.js\n\nImport d3 at the top of your script:\n\n```javascript\nimport * as d3 from 'd3';\n```\n\nOr use the CDN version (7.x):\n\n```html\n<script src=\"https://d3js.org/d3.v7.min.js\"></script>\n```\n\nAll modules (scales, axes, shapes, transitions, etc.) are accessible through the `d3` namespace.\n\n### 2. Choose the integration pattern\n\n**Pattern A: Direct DOM manipulation (recommended for most cases)**\nUse d3 to select DOM elements and manipulate them imperatively. This works in any JavaScript environment:\n\n```javascript\nfunction drawChart(data) {\n  if (!data || data.length === 0) return;\n\n  const svg = d3.select('#chart'); // Select by ID, class, or DOM element\n\n  // Clear previous content\n  svg.selectAll(\"*\").remove();\n\n  // Set up dimensions\n  const width = 800;\n  const height = 400;\n  const margin = { top: 20, right: 30, bottom: 40, left: 50 };\n\n  // Create scales, axes, and draw visualisation\n  // ... d3 code here ...\n}\n\n// Call when data changes\ndrawChart(myData);\n```\n\n**Pattern B: Declarative rendering (for frameworks with templating)**\nUse d3 for data calculations (scales, layouts) but render elements via your framework:\n\n```javascript\nfunction getChartElements(data) {\n  const xScale = d3.scaleLinear()\n    .domain([0, d3.max(data, d => d.value)])\n    .range([0, 400]);\n\n  return data.map((d, i) => ({\n    x: 50,\n    y: i * 30,\n    width: xScale(d.value),\n    height: 25\n  }));\n}\n\n// In React: {getChartElements(data).map((d, i) => <rect key={i} {...d} fill=\"steelblue\" />)}\n// In Vue: v-for directive over the returned array\n// In vanilla JS: Create elements manually from the returned data\n```\n\nUse Pattern A for complex visualisations with transitions, interactions, or when leveraging d3's full capabilities. Use Pattern B for simpler visualisations or when your framework prefers declarative rendering.\n\n### 3. Structure the visualisation code\n\nFollow this standard structure in your drawing function:\n\n```javascript\nfunction drawVisualization(data) {\n  if (!data || data.length === 0) return;\n\n  const svg = d3.select('#chart'); // Or pass a selector/element\n  svg.selectAll(\"*\").remove(); // Clear previous render\n\n  // 1. Define dimensions\n  const width = 800;\n  const height = 400;\n  const margin = { top: 20, right: 30, bottom: 40, left: 50 };\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // 2. Create main group with margins\n  const g = svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},${margin.top})`);\n\n  // 3. Create scales\n  const xScale = d3.scaleLinear()\n    .domain([0, d3.max(data, d => d.x)])\n    .range([0, innerWidth]);\n\n  const yScale = d3.scaleLinear()\n    .domain([0, d3.max(data, d => d.y)])\n    .range([innerHeight, 0]); // Note: inverted for SVG coordinates\n\n  // 4. Create and append axes\n  const xAxis = d3.axisBottom(xScale);\n  const yAxis = d3.axisLeft(yScale);\n\n  g.append(\"g\")\n    .attr(\"transform\", `translate(0,${innerHeight})`)\n    .call(xAxis);\n\n  g.append(\"g\")\n    .call(yAxis);\n\n  // 5. Bind data and create visual elements\n  g.selectAll(\"circle\")\n    .data(data)\n    .join(\"circle\")\n    .attr(\"cx\", d => xScale(d.x))\n    .attr(\"cy\", d => yScale(d.y))\n    .attr(\"r\", 5)\n    .attr(\"fill\", \"steelblue\");\n}\n\n// Call when data changes\ndrawVisualization(myData);\n```\n\n### 4. Implement responsive sizing\n\nMake visualisations responsive to container size:\n\n```javascript\nfunction setupResponsiveChart(containerId, data) {\n  const container = document.getElementById(containerId);\n  const svg = d3.select(`#${containerId}`).append('svg');\n\n  function updateChart() {\n    const { width, height } = container.getBoundingClientRect();\n    svg.attr('width', width).attr('height', height);\n\n    // Redraw visualisation with new dimensions\n    drawChart(data, svg, width, height);\n  }\n\n  // Update on initial load\n  updateChart();\n\n  // Update on window resize\n  window",
  "tags": [
    "javascript",
    "react",
    "node",
    "ai",
    "workflow",
    "template",
    "document",
    "rag",
    "seo",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-26T13:17:30.622Z"
}