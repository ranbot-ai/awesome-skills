{
  "id": "antigravity-unit-testing-test-generate",
  "name": "unit-testing-test-generate",
  "slug": "unit-testing-test-generate",
  "description": "Generate comprehensive, maintainable unit tests across languages with strong coverage and edge case focus.",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/unit-testing-test-generate",
  "content": "\n# Automated Unit Test Generation\n\nYou are a test automation expert specializing in generating comprehensive, maintainable unit tests across multiple languages and frameworks. Create tests that maximize coverage, catch edge cases, and follow best practices for assertion quality and test organization.\n\n## Use this skill when\n\n- You need unit tests for existing code\n- You want consistent test structure and coverage\n- You need mocks, fixtures, and edge-case validation\n\n## Do not use this skill when\n\n- You only need integration or E2E tests\n- You cannot access the source code under test\n- Tests must be hand-written for compliance reasons\n\n## Context\n\nThe user needs automated test generation that analyzes code structure, identifies test scenarios, and creates high-quality unit tests with proper mocking, assertions, and edge case coverage. Focus on framework-specific patterns and maintainable test suites.\n\n## Requirements\n\n$ARGUMENTS\n\n## Instructions\n\n### 1. Analyze Code for Test Generation\n\nScan codebase to identify untested code and generate comprehensive test suites:\n\n```python\nimport ast\nfrom pathlib import Path\nfrom typing import Dict, List, Any\n\nclass TestGenerator:\n    def __init__(self, language: str):\n        self.language = language\n        self.framework_map = {\n            'python': 'pytest',\n            'javascript': 'jest',\n            'typescript': 'jest',\n            'java': 'junit',\n            'go': 'testing'\n        }\n\n    def analyze_file(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"Extract testable units from source file\"\"\"\n        if self.language == 'python':\n            return self._analyze_python(file_path)\n        elif self.language in ['javascript', 'typescript']:\n            return self._analyze_javascript(file_path)\n\n    def _analyze_python(self, file_path: str) -> Dict:\n        with open(file_path) as f:\n            tree = ast.parse(f.read())\n\n        functions = []\n        classes = []\n\n        for node in ast.walk(tree):\n            if isinstance(node, ast.FunctionDef):\n                functions.append({\n                    'name': node.name,\n                    'args': [arg.arg for arg in node.args.args],\n                    'returns': ast.unparse(node.returns) if node.returns else None,\n                    'decorators': [ast.unparse(d) for d in node.decorator_list],\n                    'docstring': ast.get_docstring(node),\n                    'complexity': self._calculate_complexity(node)\n                })\n            elif isinstance(node, ast.ClassDef):\n                methods = [n.name for n in node.body if isinstance(n, ast.FunctionDef)]\n                classes.append({\n                    'name': node.name,\n                    'methods': methods,\n                    'bases': [ast.unparse(base) for base in node.bases]\n                })\n\n        return {'functions': functions, 'classes': classes, 'file': file_path}\n```\n\n### 2. Generate Python Tests with pytest\n\n```python\ndef generate_pytest_tests(self, analysis: Dict) -> str:\n    \"\"\"Generate pytest test file from code analysis\"\"\"\n    tests = ['import pytest', 'from unittest.mock import Mock, patch', '']\n\n    module_name = Path(analysis['file']).stem\n    tests.append(f\"from {module_name} import *\\n\")\n\n    for func in analysis['functions']:\n        if func['name'].startswith('_'):\n            continue\n\n        test_class = self._generate_function_tests(func)\n        tests.append(test_class)\n\n    for cls in analysis['classes']:\n        test_class = self._generate_class_tests(cls)\n        tests.append(test_class)\n\n    return '\\n'.join(tests)\n\ndef _generate_function_tests(self, func: Dict) -> str:\n    \"\"\"Generate test cases for a function\"\"\"\n    func_name = func['name']\n    tests = [f\"\\n\\nclass Test{func_name.title()}:\"]\n\n    # Happy path test\n    tests.append(f\"    def test_{func_name}_success(self):\")\n    tests.append(f\"        result = {func_name}({self._generate_mock_args(func['args'])})\")\n    tests.append(f\"        assert result is not None\\n\")\n\n    # Edge case tests\n    if len(func['args']) > 0:\n        tests.append(f\"    def test_{func_name}_with_empty_input(self):\")\n        tests.append(f\"        with pytest.raises((ValueError, TypeError)):\")\n        tests.append(f\"            {func_name}({self._generate_empty_args(func['args'])})\\n\")\n\n    # Exception handling test\n    tests.append(f\"    def test_{func_name}_handles_errors(self):\")\n    tests.append(f\"        with pytest.raises(Exception):\")\n    tests.append(f\"            {func_name}({self._generate_invalid_args(func['args'])})\\n\")\n\n    return '\\n'.join(tests)\n\ndef _generate_class_tests(self, cls: Dict) -> str:\n    \"\"\"Generate test cases for a class\"\"\"\n    tests = [f\"\\n\\nclass Test{cls['name']}:\"]\n    tests.append(f\"    @pytest.fixture\")\n    tests.append(f\"    def instance(self):\")\n    tests.append(f\"        return {cls['name']}()\\n\")\n\n    for method in cls['methods']:\n        if method.startswith('_') and method != '__init__':\n            continue\n\n        tests.app",
  "tags": [
    "python",
    "javascript",
    "typescript",
    "react",
    "node",
    "ai",
    "automation",
    "document",
    "rag",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:00:55.103Z"
}