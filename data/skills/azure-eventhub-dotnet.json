{
  "id": "antigravity-azure-eventhub-dotnet",
  "name": "azure-eventhub-dotnet",
  "slug": "azure-eventhub-dotnet",
  "description": "Azure Event Hubs SDK for .NET. Use for high-throughput event streaming: sending events (EventHubProducerClient, EventHubBufferedProducerClient), receiving events (EventProcessorClient with checkpointing), partition management, and real-time data ingestion. Triggers: \"Event Hubs\", \"event streaming\", ",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/azure-eventhub-dotnet",
  "content": "\n# Azure.Messaging.EventHubs (.NET)\n\nHigh-throughput event streaming SDK for sending and receiving events via Azure Event Hubs.\n\n## Installation\n\n```bash\n# Core package (sending and simple receiving)\ndotnet add package Azure.Messaging.EventHubs\n\n# Processor package (production receiving with checkpointing)\ndotnet add package Azure.Messaging.EventHubs.Processor\n\n# Authentication\ndotnet add package Azure.Identity\n\n# For checkpointing (required by EventProcessorClient)\ndotnet add package Azure.Storage.Blobs\n```\n\n**Current Versions**: Azure.Messaging.EventHubs v5.12.2, Azure.Messaging.EventHubs.Processor v5.12.2\n\n## Environment Variables\n\n```bash\nEVENTHUB_FULLY_QUALIFIED_NAMESPACE=<namespace>.servicebus.windows.net\nEVENTHUB_NAME=<event-hub-name>\n\n# For checkpointing (EventProcessorClient)\nBLOB_STORAGE_CONNECTION_STRING=<storage-connection-string>\nBLOB_CONTAINER_NAME=<checkpoint-container>\n\n# Alternative: Connection string auth (not recommended for production)\nEVENTHUB_CONNECTION_STRING=Endpoint=sb://<namespace>.servicebus.windows.net/;SharedAccessKeyName=...\n```\n\n## Authentication\n\n```csharp\nusing Azure.Identity;\nusing Azure.Messaging.EventHubs;\nusing Azure.Messaging.EventHubs.Producer;\n\n// Always use DefaultAzureCredential for production\nvar credential = new DefaultAzureCredential();\n\nvar fullyQualifiedNamespace = Environment.GetEnvironmentVariable(\"EVENTHUB_FULLY_QUALIFIED_NAMESPACE\");\nvar eventHubName = Environment.GetEnvironmentVariable(\"EVENTHUB_NAME\");\n\nvar producer = new EventHubProducerClient(\n    fullyQualifiedNamespace,\n    eventHubName,\n    credential);\n```\n\n**Required RBAC Roles**:\n- **Sending**: `Azure Event Hubs Data Sender`\n- **Receiving**: `Azure Event Hubs Data Receiver`\n- **Both**: `Azure Event Hubs Data Owner`\n\n## Client Types\n\n| Client | Purpose | When to Use |\n|--------|---------|-------------|\n| `EventHubProducerClient` | Send events immediately in batches | Real-time sending, full control over batching |\n| `EventHubBufferedProducerClient` | Automatic batching with background sending | High-volume, fire-and-forget scenarios |\n| `EventHubConsumerClient` | Simple event reading | Prototyping only, NOT for production |\n| `EventProcessorClient` | Production event processing | **Always use this for receiving in production** |\n\n## Core Workflow\n\n### 1. Send Events (Batch)\n\n```csharp\nusing Azure.Identity;\nusing Azure.Messaging.EventHubs;\nusing Azure.Messaging.EventHubs.Producer;\n\nawait using var producer = new EventHubProducerClient(\n    fullyQualifiedNamespace,\n    eventHubName,\n    new DefaultAzureCredential());\n\n// Create a batch (respects size limits automatically)\nusing EventDataBatch batch = await producer.CreateBatchAsync();\n\n// Add events to batch\nvar events = new[]\n{\n    new EventData(BinaryData.FromString(\"{\\\"id\\\": 1, \\\"message\\\": \\\"Hello\\\"}\")),\n    new EventData(BinaryData.FromString(\"{\\\"id\\\": 2, \\\"message\\\": \\\"World\\\"}\"))\n};\n\nforeach (var eventData in events)\n{\n    if (!batch.TryAdd(eventData))\n    {\n        // Batch is full - send it and create a new one\n        await producer.SendAsync(batch);\n        batch = await producer.CreateBatchAsync();\n        \n        if (!batch.TryAdd(eventData))\n        {\n            throw new Exception(\"Event too large for empty batch\");\n        }\n    }\n}\n\n// Send remaining events\nif (batch.Count > 0)\n{\n    await producer.SendAsync(batch);\n}\n```\n\n### 2. Send Events (Buffered - High Volume)\n\n```csharp\nusing Azure.Messaging.EventHubs.Producer;\n\nvar options = new EventHubBufferedProducerClientOptions\n{\n    MaximumWaitTime = TimeSpan.FromSeconds(1)\n};\n\nawait using var producer = new EventHubBufferedProducerClient(\n    fullyQualifiedNamespace,\n    eventHubName,\n    new DefaultAzureCredential(),\n    options);\n\n// Handle send success/failure\nproducer.SendEventBatchSucceededAsync += args =>\n{\n    Console.WriteLine($\"Batch sent: {args.EventBatch.Count} events\");\n    return Task.CompletedTask;\n};\n\nproducer.SendEventBatchFailedAsync += args =>\n{\n    Console.WriteLine($\"Batch failed: {args.Exception.Message}\");\n    return Task.CompletedTask;\n};\n\n// Enqueue events (sent automatically in background)\nfor (int i = 0; i < 1000; i++)\n{\n    await producer.EnqueueEventAsync(new EventData($\"Event {i}\"));\n}\n\n// Flush remaining events before disposing\nawait producer.FlushAsync();\n```\n\n### 3. Receive Events (Production - EventProcessorClient)\n\n```csharp\nusing Azure.Identity;\nusing Azure.Messaging.EventHubs;\nusing Azure.Messaging.EventHubs.Consumer;\nusing Azure.Messaging.EventHubs.Processor;\nusing Azure.Storage.Blobs;\n\n// Blob container for checkpointing\nvar blobClient = new BlobContainerClient(\n    Environment.GetEnvironmentVariable(\"BLOB_STORAGE_CONNECTION_STRING\"),\n    Environment.GetEnvironmentVariable(\"BLOB_CONTAINER_NAME\"));\n\nawait blobClient.CreateIfNotExistsAsync();\n\n// Create processor\nvar processor = new EventProcessorClient(\n    blobClient,\n    EventHubConsumerClient.DefaultConsumerGroup,\n    fullyQualifiedNamespace,\n    eventHubName,\n    new DefaultAzureCredential());",
  "tags": [
    "ai",
    "workflow",
    "azure",
    "rag",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-02-12T07:15:43.076Z"
}