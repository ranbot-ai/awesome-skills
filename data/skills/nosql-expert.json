{
  "id": "antigravity-nosql-expert",
  "name": "nosql-expert",
  "slug": "nosql-expert",
  "description": "Expert guidance for distributed NoSQL databases (Cassandra, DynamoDB). Focuses on mental models, query-first modeling, single-table design, and avoiding hot partitions in high-scale systems.",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/nosql-expert",
  "content": "\n# NoSQL Expert Patterns (Cassandra & DynamoDB)\n\n## Overview\n\nThis skill provides professional mental models and design patterns for **distributed wide-column and key-value stores** (specifically Apache Cassandra and Amazon DynamoDB).\n\nUnlike SQL (where you model data entities), or document stores (like MongoDB), these distributed systems require you to **model your queries first**.\n\n## When to Use\n\n- **Designing for Scale**: Moving beyond simple single-node databases to distributed clusters.\n- **Technology Selection**: Evaluating or using **Cassandra**, **ScyllaDB**, or **DynamoDB**.\n- **Performance Tuning**: Troubleshooting \"hot partitions\" or high latency in existing NoSQL systems.\n- **Microservices**: Implementing \"database-per-service\" patterns where highly optimized reads are required.\n\n## The Mental Shift: SQL vs. Distributed NoSQL\n\n| Feature | SQL (Relational) | Distributed NoSQL (Cassandra/DynamoDB) |\n| :--- | :--- | :--- |\n| **Data modeling** | Model Entities + Relationships | Model **Queries** (Access Patterns) |\n| **Joins** | CPU-intensive, at read time | **Pre-computed** (Denormalized) at write time |\n| **Storage cost** | Expensive (minimize duplication) | Cheap (duplicate data for read speed) |\n| **Consistency** | ACID (Strong) | **BASE (Eventual)** / Tunable |\n| **Scalability** | Vertical (Bigger machine) | **Horizontal** (More nodes/shards) |\n\n> **The Golden Rule:** In SQL, you design the data model to answer *any* query. In NoSQL, you design the data model to answer *specific* queries efficiently.\n\n## Core Design Patterns\n\n### 1. Query-First Modeling (Access Patterns)\n\nYou typically cannot \"add a query later\" without migration or creating a new table/index.\n\n**Process:**\n1.  **List all Entities** (User, Order, Product).\n2.  **List all Access Patterns** (\"Get User by Email\", \"Get Orders by User sorted by Date\").\n3.  **Design Table(s)** specifically to serve those patterns with a single lookup.\n\n### 2. The Partition Key is King\n\nData is distributed across physical nodes based on the **Partition Key (PK)**.\n-   **Goal:** Even distribution of data and traffic.\n-   **Anti-Pattern:** Using a low-cardinality PK (e.g., `status=\"active\"` or `gender=\"m\"`) creates **Hot Partitions**, limiting throughput to a single node's capacity.\n-   **Best Practice:** Use high-cardinality keys (User IDs, Device IDs, Composite Keys).\n\n### 3. Clustering / Sort Keys\n\nWithin a partition, data is sorted on disk by the **Clustering Key (Cassandra)** or **Sort Key (DynamoDB)**.\n-   This allows for efficient **Range Queries** (e.g., `WHERE user_id=X AND date > Y`).\n-   It effectively pre-sorts your data for specific retrieval requirements.\n\n### 4. Single-Table Design (Adjacency Lists)\n\n*Primary use: DynamoDB (but concepts apply elsewhere)*\n\nStoring multiple entity types in one table to enable pre-joined reads.\n\n| PK (Partition) | SK (Sort) | Data Fields... |\n| :--- | :--- | :--- |\n| `USER#123` | `PROFILE` | `{ name: \"Ian\", email: \"...\" }` |\n| `USER#123` | `ORDER#998` | `{ total: 50.00, status: \"shipped\" }` |\n| `USER#123` | `ORDER#999` | `{ total: 12.00, status: \"pending\" }` |\n\n-   **Query:** `PK=\"USER#123\"`\n-   **Result:** Fetches User Profile AND all Orders in **one network request**.\n\n### 5. Denormalization & Duplication\n\nDon't be afraid to store the same data in multiple tables to serve different query patterns.\n-   **Table A:** `users_by_id` (PK: uuid)\n-   **Table B:** `users_by_email` (PK: email)\n\n*Trade-off: You must manage data consistency across tables (often using eventual consistency or batch writes).*\n\n## Specific Guidance\n\n### Apache Cassandra / ScyllaDB\n\n-   **Primary Key Structure:** `((Partition Key), Clustering Columns)`\n-   **No Joins, No Aggregates:** Do not try to `JOIN` or `GROUP BY`. Pre-calculate aggregates in a separate counter table.\n-   **Avoid `ALLOW FILTERING`:** If you see this in production, your data model is wrong. It implies a full cluster scan.\n-   **Writes are Cheap:** Inserts and Updates are just appends to the LSM tree. Don't worry about write volume as much as read efficiency.\n-   **Tombstones:** Deletes are expensive markers. Avoid high-velocity delete patterns (like queues) in standard tables.\n\n### AWS DynamoDB\n\n-   **GSI (Global Secondary Index):** Use GSIs to create alternative views of your data (e.g., \"Search Orders by Date\" instead of by User).\n    -   *Note:* GSIs are eventually consistent.\n-   **LSI (Local Secondary Index):** Sorts data differently *within* the same partition. Must be created at table creation time.\n-   **WCU / RCU:** Understand capacity modes. Single-table design helps optimize consumed capacity units.\n-   **TTL:** Use Time-To-Live attributes to automatically expire old data (free delete) without creating tombstones.\n\n## Expert Checklist\n\nBefore finalizing your NoSQL schema:\n\n-   [ ] **Access Pattern Coverage:** Does every query pattern map to a specific table or index?\n-   [ ] **Cardinality Check:** Does the Partition Key have enough unique values to spread t",
  "tags": [
    "node",
    "ai",
    "design",
    "document",
    "aws",
    "rag",
    "cro"
  ],
  "useCases": [
    "**Designing for Scale**: Moving beyond simple single-node databases to distributed clusters.",
    "**Technology Selection**: Evaluating or using **Cassandra**, **ScyllaDB**, or **DynamoDB**.",
    "**Performance Tuning**: Troubleshooting \"hot partitions\" or high latency in existing NoSQL systems.",
    "**Microservices**: Implementing \"database-per-service\" patterns where highly optimized reads are required."
  ],
  "scrapedAt": "2026-01-26T13:19:52.279Z"
}