{
  "id": "antigravity-agent-orchestration-multi-agent-optimize",
  "name": "agent-orchestration-multi-agent-optimize",
  "slug": "agent-orchestration-multi-agent-optimize",
  "description": "Optimize multi-agent systems with coordinated profiling, workload distribution, and cost-aware orchestration. Use when improving agent performance, throughput, or reliability.",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/agent-orchestration-multi-agent-optimize",
  "content": "\n# Multi-Agent Optimization Toolkit\n\n## Use this skill when\n\n- Improving multi-agent coordination, throughput, or latency\n- Profiling agent workflows to identify bottlenecks\n- Designing orchestration strategies for complex workflows\n- Optimizing cost, context usage, or tool efficiency\n\n## Do not use this skill when\n\n- You only need to tune a single agent prompt\n- There are no measurable metrics or evaluation data\n- The task is unrelated to multi-agent orchestration\n\n## Instructions\n\n1. Establish baseline metrics and target performance goals.\n2. Profile agent workloads and identify coordination bottlenecks.\n3. Apply orchestration changes and cost controls incrementally.\n4. Validate improvements with repeatable tests and rollbacks.\n\n## Safety\n\n- Avoid deploying orchestration changes without regression testing.\n- Roll out changes gradually to prevent system-wide regressions.\n\n## Role: AI-Powered Multi-Agent Performance Engineering Specialist\n\n### Context\n\nThe Multi-Agent Optimization Tool is an advanced AI-driven framework designed to holistically improve system performance through intelligent, coordinated agent-based optimization. Leveraging cutting-edge AI orchestration techniques, this tool provides a comprehensive approach to performance engineering across multiple domains.\n\n### Core Capabilities\n\n- Intelligent multi-agent coordination\n- Performance profiling and bottleneck identification\n- Adaptive optimization strategies\n- Cross-domain performance optimization\n- Cost and efficiency tracking\n\n## Arguments Handling\n\nThe tool processes optimization arguments with flexible input parameters:\n\n- `$TARGET`: Primary system/application to optimize\n- `$PERFORMANCE_GOALS`: Specific performance metrics and objectives\n- `$OPTIMIZATION_SCOPE`: Depth of optimization (quick-win, comprehensive)\n- `$BUDGET_CONSTRAINTS`: Cost and resource limitations\n- `$QUALITY_METRICS`: Performance quality thresholds\n\n## 1. Multi-Agent Performance Profiling\n\n### Profiling Strategy\n\n- Distributed performance monitoring across system layers\n- Real-time metrics collection and analysis\n- Continuous performance signature tracking\n\n#### Profiling Agents\n\n1. **Database Performance Agent**\n   - Query execution time analysis\n   - Index utilization tracking\n   - Resource consumption monitoring\n\n2. **Application Performance Agent**\n   - CPU and memory profiling\n   - Algorithmic complexity assessment\n   - Concurrency and async operation analysis\n\n3. **Frontend Performance Agent**\n   - Rendering performance metrics\n   - Network request optimization\n   - Core Web Vitals monitoring\n\n### Profiling Code Example\n\n```python\ndef multi_agent_profiler(target_system):\n    agents = [\n        DatabasePerformanceAgent(target_system),\n        ApplicationPerformanceAgent(target_system),\n        FrontendPerformanceAgent(target_system)\n    ]\n\n    performance_profile = {}\n    for agent in agents:\n        performance_profile[agent.__class__.__name__] = agent.profile()\n\n    return aggregate_performance_metrics(performance_profile)\n```\n\n## 2. Context Window Optimization\n\n### Optimization Techniques\n\n- Intelligent context compression\n- Semantic relevance filtering\n- Dynamic context window resizing\n- Token budget management\n\n### Context Compression Algorithm\n\n```python\ndef compress_context(context, max_tokens=4000):\n    # Semantic compression using embedding-based truncation\n    compressed_context = semantic_truncate(\n        context,\n        max_tokens=max_tokens,\n        importance_threshold=0.7\n    )\n    return compressed_context\n```\n\n## 3. Agent Coordination Efficiency\n\n### Coordination Principles\n\n- Parallel execution design\n- Minimal inter-agent communication overhead\n- Dynamic workload distribution\n- Fault-tolerant agent interactions\n\n### Orchestration Framework\n\n```python\nclass MultiAgentOrchestrator:\n    def __init__(self, agents):\n        self.agents = agents\n        self.execution_queue = PriorityQueue()\n        self.performance_tracker = PerformanceTracker()\n\n    def optimize(self, target_system):\n        # Parallel agent execution with coordinated optimization\n        with concurrent.futures.ThreadPoolExecutor() as executor:\n            futures = {\n                executor.submit(agent.optimize, target_system): agent\n                for agent in self.agents\n            }\n\n            for future in concurrent.futures.as_completed(futures):\n                agent = futures[future]\n                result = future.result()\n                self.performance_tracker.log(agent, result)\n```\n\n## 4. Parallel Execution Optimization\n\n### Key Strategies\n\n- Asynchronous agent processing\n- Workload partitioning\n- Dynamic resource allocation\n- Minimal blocking operations\n\n## 5. Cost Optimization Strategies\n\n### LLM Cost Management\n\n- Token usage tracking\n- Adaptive model selection\n- Caching and result reuse\n- Efficient prompt engineering\n\n### Cost Tracking Example\n\n```python\nclass CostOptimizer:\n    def __init__(self):\n        self.token_budget = 100000  # Monthly budget\n      ",
  "tags": [
    "python",
    "api",
    "claude",
    "ai",
    "agent",
    "llm",
    "gpt",
    "workflow",
    "design",
    "rag"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:57:52.402Z"
}