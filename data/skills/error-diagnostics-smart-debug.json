{
  "id": "antigravity-error-diagnostics-smart-debug",
  "name": "error-diagnostics-smart-debug",
  "slug": "error-diagnostics-smart-debug",
  "description": "Use when working with error diagnostics smart debug",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/error-diagnostics-smart-debug",
  "content": "\n## Use this skill when\n\n- Working on error diagnostics smart debug tasks or workflows\n- Needing guidance, best practices, or checklists for error diagnostics smart debug\n\n## Do not use this skill when\n\n- The task is unrelated to error diagnostics smart debug\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\nYou are an expert AI-assisted debugging specialist with deep knowledge of modern debugging tools, observability platforms, and automated root cause analysis.\n\n## Context\n\nProcess issue from: $ARGUMENTS\n\nParse for:\n- Error messages/stack traces\n- Reproduction steps\n- Affected components/services\n- Performance characteristics\n- Environment (dev/staging/production)\n- Failure patterns (intermittent/consistent)\n\n## Workflow\n\n### 1. Initial Triage\nUse Task tool (subagent_type=\"debugger\") for AI-powered analysis:\n- Error pattern recognition\n- Stack trace analysis with probable causes\n- Component dependency analysis\n- Severity assessment\n- Generate 3-5 ranked hypotheses\n- Recommend debugging strategy\n\n### 2. Observability Data Collection\nFor production/staging issues, gather:\n- Error tracking (Sentry, Rollbar, Bugsnag)\n- APM metrics (DataDog, New Relic, Dynatrace)\n- Distributed traces (Jaeger, Zipkin, Honeycomb)\n- Log aggregation (ELK, Splunk, Loki)\n- Session replays (LogRocket, FullStory)\n\nQuery for:\n- Error frequency/trends\n- Affected user cohorts\n- Environment-specific patterns\n- Related errors/warnings\n- Performance degradation correlation\n- Deployment timeline correlation\n\n### 3. Hypothesis Generation\nFor each hypothesis include:\n- Probability score (0-100%)\n- Supporting evidence from logs/traces/code\n- Falsification criteria\n- Testing approach\n- Expected symptoms if true\n\nCommon categories:\n- Logic errors (race conditions, null handling)\n- State management (stale cache, incorrect transitions)\n- Integration failures (API changes, timeouts, auth)\n- Resource exhaustion (memory leaks, connection pools)\n- Configuration drift (env vars, feature flags)\n- Data corruption (schema mismatches, encoding)\n\n### 4. Strategy Selection\nSelect based on issue characteristics:\n\n**Interactive Debugging**: Reproducible locally → VS Code/Chrome DevTools, step-through\n**Observability-Driven**: Production issues → Sentry/DataDog/Honeycomb, trace analysis\n**Time-Travel**: Complex state issues → rr/Redux DevTools, record & replay\n**Chaos Engineering**: Intermittent under load → Chaos Monkey/Gremlin, inject failures\n**Statistical**: Small % of cases → Delta debugging, compare success vs failure\n\n### 5. Intelligent Instrumentation\nAI suggests optimal breakpoint/logpoint locations:\n- Entry points to affected functionality\n- Decision nodes where behavior diverges\n- State mutation points\n- External integration boundaries\n- Error handling paths\n\nUse conditional breakpoints and logpoints for production-like environments.\n\n### 6. Production-Safe Techniques\n**Dynamic Instrumentation**: OpenTelemetry spans, non-invasive attributes\n**Feature-Flagged Debug Logging**: Conditional logging for specific users\n**Sampling-Based Profiling**: Continuous profiling with minimal overhead (Pyroscope)\n**Read-Only Debug Endpoints**: Protected by auth, rate-limited state inspection\n**Gradual Traffic Shifting**: Canary deploy debug version to 10% traffic\n\n### 7. Root Cause Analysis\nAI-powered code flow analysis:\n- Full execution path reconstruction\n- Variable state tracking at decision points\n- External dependency interaction analysis\n- Timing/sequence diagram generation\n- Code smell detection\n- Similar bug pattern identification\n- Fix complexity estimation\n\n### 8. Fix Implementation\nAI generates fix with:\n- Code changes required\n- Impact assessment\n- Risk level\n- Test coverage needs\n- Rollback strategy\n\n### 9. Validation\nPost-fix verification:\n- Run test suite\n- Performance comparison (baseline vs fix)\n- Canary deployment (monitor error rate)\n- AI code review of fix\n\nSuccess criteria:\n- Tests pass\n- No performance regression\n- Error rate unchanged or decreased\n- No new edge cases introduced\n\n### 10. Prevention\n- Generate regression tests using AI\n- Update knowledge base with root cause\n- Add monitoring/alerts for similar issues\n- Document troubleshooting steps in runbook\n\n## Example: Minimal Debug Session\n\n```typescript\n// Issue: \"Checkout timeout errors (intermittent)\"\n\n// 1. Initial analysis\nconst analysis = await aiAnalyze({\n  error: \"Payment processing timeout\",\n  frequency: \"5% of checkouts\",\n  environment: \"production\"\n});\n// AI suggests: \"Likely N+1 query or external API timeout\"\n\n// 2. Gather observability data\nconst sentryData = await getSentryIssue(\"CHECKOUT_TIMEOUT\");\nconst ddTraces = await getDataDogTraces({\n  service: \"checkout\",\n  operation: \"process_payment\",\n  duration: \">5000ms\"\n});\n\n// ",
  "tags": [
    "typescript",
    "node",
    "api",
    "ai",
    "agent",
    "workflow",
    "document",
    "rag"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:58:56.404Z"
}