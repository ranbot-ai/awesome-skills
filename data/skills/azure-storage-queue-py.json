{
  "id": "antigravity-azure-storage-queue-py",
  "name": "azure-storage-queue-py",
  "slug": "azure-storage-queue-py",
  "description": "Azure Queue Storage SDK for Python. Use for reliable message queuing, task distribution, and asynchronous processing.\nTriggers: \"queue storage\", \"QueueServiceClient\", \"QueueClient\", \"message queue\", \"dequeue\".\n",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/azure-storage-queue-py",
  "content": "\n# Azure Queue Storage SDK for Python\n\nSimple, cost-effective message queuing for asynchronous communication.\n\n## Installation\n\n```bash\npip install azure-storage-queue azure-identity\n```\n\n## Environment Variables\n\n```bash\nAZURE_STORAGE_ACCOUNT_URL=https://<account>.queue.core.windows.net\n```\n\n## Authentication\n\n```python\nfrom azure.identity import DefaultAzureCredential\nfrom azure.storage.queue import QueueServiceClient, QueueClient\n\ncredential = DefaultAzureCredential()\naccount_url = \"https://<account>.queue.core.windows.net\"\n\n# Service client\nservice_client = QueueServiceClient(account_url=account_url, credential=credential)\n\n# Queue client\nqueue_client = QueueClient(account_url=account_url, queue_name=\"myqueue\", credential=credential)\n```\n\n## Queue Operations\n\n```python\n# Create queue\nservice_client.create_queue(\"myqueue\")\n\n# Get queue client\nqueue_client = service_client.get_queue_client(\"myqueue\")\n\n# Delete queue\nservice_client.delete_queue(\"myqueue\")\n\n# List queues\nfor queue in service_client.list_queues():\n    print(queue.name)\n```\n\n## Send Messages\n\n```python\n# Send message (string)\nqueue_client.send_message(\"Hello, Queue!\")\n\n# Send with options\nqueue_client.send_message(\n    content=\"Delayed message\",\n    visibility_timeout=60,  # Hidden for 60 seconds\n    time_to_live=3600       # Expires in 1 hour\n)\n\n# Send JSON\nimport json\ndata = {\"task\": \"process\", \"id\": 123}\nqueue_client.send_message(json.dumps(data))\n```\n\n## Receive Messages\n\n```python\n# Receive messages (makes them invisible temporarily)\nmessages = queue_client.receive_messages(\n    messages_per_page=10,\n    visibility_timeout=30  # 30 seconds to process\n)\n\nfor message in messages:\n    print(f\"ID: {message.id}\")\n    print(f\"Content: {message.content}\")\n    print(f\"Dequeue count: {message.dequeue_count}\")\n    \n    # Process message...\n    \n    # Delete after processing\n    queue_client.delete_message(message)\n```\n\n## Peek Messages\n\n```python\n# Peek without hiding (doesn't affect visibility)\nmessages = queue_client.peek_messages(max_messages=5)\n\nfor message in messages:\n    print(message.content)\n```\n\n## Update Message\n\n```python\n# Extend visibility or update content\nmessages = queue_client.receive_messages()\nfor message in messages:\n    # Extend timeout (need more time)\n    queue_client.update_message(\n        message,\n        visibility_timeout=60\n    )\n    \n    # Update content and timeout\n    queue_client.update_message(\n        message,\n        content=\"Updated content\",\n        visibility_timeout=60\n    )\n```\n\n## Delete Message\n\n```python\n# Delete after successful processing\nmessages = queue_client.receive_messages()\nfor message in messages:\n    try:\n        # Process...\n        queue_client.delete_message(message)\n    except Exception:\n        # Message becomes visible again after timeout\n        pass\n```\n\n## Clear Queue\n\n```python\n# Delete all messages\nqueue_client.clear_messages()\n```\n\n## Queue Properties\n\n```python\n# Get queue properties\nproperties = queue_client.get_queue_properties()\nprint(f\"Approximate message count: {properties.approximate_message_count}\")\n\n# Set/get metadata\nqueue_client.set_queue_metadata(metadata={\"environment\": \"production\"})\nproperties = queue_client.get_queue_properties()\nprint(properties.metadata)\n```\n\n## Async Client\n\n```python\nfrom azure.storage.queue.aio import QueueServiceClient, QueueClient\nfrom azure.identity.aio import DefaultAzureCredential\n\nasync def queue_operations():\n    credential = DefaultAzureCredential()\n    \n    async with QueueClient(\n        account_url=\"https://<account>.queue.core.windows.net\",\n        queue_name=\"myqueue\",\n        credential=credential\n    ) as client:\n        # Send\n        await client.send_message(\"Async message\")\n        \n        # Receive\n        async for message in client.receive_messages():\n            print(message.content)\n            await client.delete_message(message)\n\nimport asyncio\nasyncio.run(queue_operations())\n```\n\n## Base64 Encoding\n\n```python\nfrom azure.storage.queue import QueueClient, BinaryBase64EncodePolicy, BinaryBase64DecodePolicy\n\n# For binary data\nqueue_client = QueueClient(\n    account_url=account_url,\n    queue_name=\"myqueue\",\n    credential=credential,\n    message_encode_policy=BinaryBase64EncodePolicy(),\n    message_decode_policy=BinaryBase64DecodePolicy()\n)\n\n# Send bytes\nqueue_client.send_message(b\"Binary content\")\n```\n\n## Best Practices\n\n1. **Delete messages after processing** to prevent reprocessing\n2. **Set appropriate visibility timeout** based on processing time\n3. **Handle `dequeue_count`** for poison message detection\n4. **Use async client** for high-throughput scenarios\n5. **Use `peek_messages`** for monitoring without affecting queue\n6. **Set `time_to_live`** to prevent stale messages\n7. **Consider Service Bus** for advanced features (sessions, topics)\n",
  "tags": [
    "python",
    "ai",
    "azure",
    "rag"
  ],
  "useCases": [],
  "scrapedAt": "2026-02-12T07:16:02.565Z"
}