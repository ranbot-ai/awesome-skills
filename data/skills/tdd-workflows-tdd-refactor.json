{
  "id": "antigravity-tdd-workflows-tdd-refactor",
  "name": "tdd-workflows-tdd-refactor",
  "slug": "tdd-workflows-tdd-refactor",
  "description": "Use when working with tdd workflows tdd refactor",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/tdd-workflows-tdd-refactor",
  "content": "\n## Use this skill when\n\n- Working on tdd workflows tdd refactor tasks or workflows\n- Needing guidance, best practices, or checklists for tdd workflows tdd refactor\n\n## Do not use this skill when\n\n- The task is unrelated to tdd workflows tdd refactor\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\nRefactor code with confidence using comprehensive test safety net:\n\n[Extended thinking: This tool uses the tdd-orchestrator agent (opus model) for sophisticated refactoring while maintaining all tests green. It applies design patterns, improves code quality, and optimizes performance with the safety of comprehensive test coverage.]\n\n## Usage\n\nUse Task tool with subagent_type=\"tdd-orchestrator\" to perform safe refactoring.\n\nPrompt: \"Refactor this code while keeping all tests green: $ARGUMENTS. Apply TDD refactor phase:\n\n## Core Process\n\n**1. Pre-Assessment**\n- Run tests to establish green baseline\n- Analyze code smells and test coverage\n- Document current performance metrics\n- Create incremental refactoring plan\n\n**2. Code Smell Detection**\n- Duplicated code → Extract methods/classes\n- Long methods → Decompose into focused functions\n- Large classes → Split responsibilities\n- Long parameter lists → Parameter objects\n- Feature Envy → Move methods to appropriate classes\n- Primitive Obsession → Value objects\n- Switch statements → Polymorphism\n- Dead code → Remove\n\n**3. Design Patterns**\n- Apply Creational (Factory, Builder, Singleton)\n- Apply Structural (Adapter, Facade, Decorator)\n- Apply Behavioral (Strategy, Observer, Command)\n- Apply Domain (Repository, Service, Value Objects)\n- Use patterns only where they add clear value\n\n**4. SOLID Principles**\n- Single Responsibility: One reason to change\n- Open/Closed: Open for extension, closed for modification\n- Liskov Substitution: Subtypes substitutable\n- Interface Segregation: Small, focused interfaces\n- Dependency Inversion: Depend on abstractions\n\n**5. Refactoring Techniques**\n- Extract Method/Variable/Interface\n- Inline unnecessary indirection\n- Rename for clarity\n- Move Method/Field to appropriate classes\n- Replace Magic Numbers with constants\n- Encapsulate fields\n- Replace Conditional with Polymorphism\n- Introduce Null Object\n\n**6. Performance Optimization**\n- Profile to identify bottlenecks\n- Optimize algorithms and data structures\n- Implement caching where beneficial\n- Reduce database queries (N+1 elimination)\n- Lazy loading and pagination\n- Always measure before and after\n\n**7. Incremental Steps**\n- Make small, atomic changes\n- Run tests after each modification\n- Commit after each successful refactoring\n- Keep refactoring separate from behavior changes\n- Use scaffolding when needed\n\n**8. Architecture Evolution**\n- Layer separation and dependency management\n- Module boundaries and interface definition\n- Event-driven patterns for decoupling\n- Database access pattern optimization\n\n**9. Safety Verification**\n- Run full test suite after each change\n- Performance regression testing\n- Mutation testing for test effectiveness\n- Rollback plan for major changes\n\n**10. Advanced Patterns**\n- Strangler Fig: Gradual legacy replacement\n- Branch by Abstraction: Large-scale changes\n- Parallel Change: Expand-contract pattern\n- Mikado Method: Dependency graph navigation\n\n## Output Requirements\n\n- Refactored code with improvements applied\n- Test results (all green)\n- Before/after metrics comparison\n- Applied refactoring techniques list\n- Performance improvement measurements\n- Remaining technical debt assessment\n\n## Safety Checklist\n\nBefore committing:\n- ✓ All tests pass (100% green)\n- ✓ No functionality regression\n- ✓ Performance metrics acceptable\n- ✓ Code coverage maintained/improved\n- ✓ Documentation updated\n\n## Recovery Protocol\n\nIf tests fail:\n- Immediately revert last change\n- Identify breaking refactoring\n- Apply smaller incremental changes\n- Use version control for safe experimentation\n\n## Example: Extract Method Pattern\n\n**Before:**\n```typescript\nclass OrderProcessor {\n  processOrder(order: Order): ProcessResult {\n    // Validation\n    if (!order.customerId || order.items.length === 0) {\n      return { success: false, error: \"Invalid order\" };\n    }\n\n    // Calculate totals\n    let subtotal = 0;\n    for (const item of order.items) {\n      subtotal += item.price * item.quantity;\n    }\n    let total = subtotal + (subtotal * 0.08) + (subtotal > 100 ? 0 : 15);\n\n    // Process payment...\n    // Update inventory...\n    // Send confirmation...\n  }\n}\n```\n\n**After:**\n```typescript\nclass OrderProcessor {\n  async processOrder(order: Order): Promise<ProcessResult> {\n    const validation = this.validateOrder(order);\n    if (!validation.isValid) return ProcessResult.failure(validation.error);\n\n    const orderTotal = OrderTotal.calcul",
  "tags": [
    "typescript",
    "ai",
    "agent",
    "workflow",
    "design",
    "document",
    "rag"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:00:44.358Z"
}