{
  "id": "antigravity-bash-pro",
  "name": "bash-pro",
  "slug": "bash-pro",
  "description": "Master of defensive Bash scripting for production automation, CI/CD pipelines, and system utilities. Expert in safe, portable, and testable shell scripts.",
  "category": "Security & Systems",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/bash-pro",
  "content": "## Use this skill when\n\n- Writing or reviewing Bash scripts for automation, CI/CD, or ops\n- Hardening shell scripts for safety and portability\n\n## Do not use this skill when\n\n- You need POSIX-only shell without Bash features\n- The task requires a higher-level language for complex logic\n- You need Windows-native scripting (PowerShell)\n\n## Instructions\n\n1. Define script inputs, outputs, and failure modes.\n2. Apply strict mode and safe argument parsing.\n3. Implement core logic with defensive patterns.\n4. Add tests and linting with Bats and ShellCheck.\n\n## Safety\n\n- Treat input as untrusted; avoid eval and unsafe globbing.\n- Prefer dry-run modes before destructive actions.\n\n## Focus Areas\n\n- Defensive programming with strict error handling\n- POSIX compliance and cross-platform portability\n- Safe argument parsing and input validation\n- Robust file operations and temporary resource management\n- Process orchestration and pipeline safety\n- Production-grade logging and error reporting\n- Comprehensive testing with Bats framework\n- Static analysis with ShellCheck and formatting with shfmt\n- Modern Bash 5.x features and best practices\n- CI/CD integration and automation workflows\n\n## Approach\n\n- Always use strict mode with `set -Eeuo pipefail` and proper error trapping\n- Quote all variable expansions to prevent word splitting and globbing issues\n- Prefer arrays and proper iteration over unsafe patterns like `for f in $(ls)`\n- Use `[[ ]]` for Bash conditionals, fall back to `[ ]` for POSIX compliance\n- Implement comprehensive argument parsing with `getopts` and usage functions\n- Create temporary files and directories safely with `mktemp` and cleanup traps\n- Prefer `printf` over `echo` for predictable output formatting\n- Use command substitution `$()` instead of backticks for readability\n- Implement structured logging with timestamps and configurable verbosity\n- Design scripts to be idempotent and support dry-run modes\n- Use `shopt -s inherit_errexit` for better error propagation in Bash 4.4+\n- Employ `IFS=$'\\n\\t'` to prevent unwanted word splitting on spaces\n- Validate inputs with `: \"${VAR:?message}\"` for required environment variables\n- End option parsing with `--` and use `rm -rf -- \"$dir\"` for safe operations\n- Support `--trace` mode with `set -x` opt-in for detailed debugging\n- Use `xargs -0` with NUL boundaries for safe subprocess orchestration\n- Employ `readarray`/`mapfile` for safe array population from command output\n- Implement robust script directory detection: `SCRIPT_DIR=\"$(cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" && pwd -P)\"`\n- Use NUL-safe patterns: `find -print0 | while IFS= read -r -d '' file; do ...; done`\n\n## Compatibility & Portability\n\n- Use `#!/usr/bin/env bash` shebang for portability across systems\n- Check Bash version at script start: `(( BASH_VERSINFO[0] >= 4 && BASH_VERSINFO[1] >= 4 ))` for Bash 4.4+ features\n- Validate required external commands exist: `command -v jq &>/dev/null || exit 1`\n- Detect platform differences: `case \"$(uname -s)\" in Linux*) ... ;; Darwin*) ... ;; esac`\n- Handle GNU vs BSD tool differences (e.g., `sed -i` vs `sed -i ''`)\n- Test scripts on all target platforms (Linux, macOS, BSD variants)\n- Document minimum version requirements in script header comments\n- Provide fallback implementations for platform-specific features\n- Use built-in Bash features over external commands when possible for portability\n- Avoid bashisms when POSIX compliance is required, document when using Bash-specific features\n\n## Readability & Maintainability\n\n- Use long-form options in scripts for clarity: `--verbose` instead of `-v`\n- Employ consistent naming: snake_case for functions/variables, UPPER_CASE for constants\n- Add section headers with comment blocks to organize related functions\n- Keep functions under 50 lines; refactor larger functions into smaller components\n- Group related functions together with descriptive section headers\n- Use descriptive function names that explain purpose: `validate_input_file` not `check_file`\n- Add inline comments for non-obvious logic, avoid stating the obvious\n- Maintain consistent indentation (2 or 4 spaces, never tabs mixed with spaces)\n- Place opening braces on same line for consistency: `function_name() {`\n- Use blank lines to separate logical blocks within functions\n- Document function parameters and return values in header comments\n- Extract magic numbers and strings to named constants at top of script\n\n## Safety & Security Patterns\n\n- Declare constants with `readonly` to prevent accidental modification\n- Use `local` keyword for all function variables to avoid polluting global scope\n- Implement `timeout` for external commands: `timeout 30s curl ...` prevents hangs\n- Validate file permissions before operations: `[[ -r \"$file\" ]] || exit 1`\n- Use process substitution `<(command)` instead of temporary files when possible\n- Sanitize user input before using in commands or file operations\n- Validate numeric input with pattern matching: `[[ $num =~ ^[0-9]+$ ]]`",
  "tags": [
    "markdown",
    "ai",
    "llm",
    "automation",
    "workflow",
    "design",
    "document",
    "image",
    "security",
    "vulnerability"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:58:08.609Z"
}