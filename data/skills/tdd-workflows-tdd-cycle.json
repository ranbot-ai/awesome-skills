{
  "id": "antigravity-tdd-workflows-tdd-cycle",
  "name": "tdd-workflows-tdd-cycle",
  "slug": "tdd-workflows-tdd-cycle",
  "description": "Use when working with tdd workflows tdd cycle",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/tdd-workflows-tdd-cycle",
  "content": "\n## Use this skill when\n\n- Working on tdd workflows tdd cycle tasks or workflows\n- Needing guidance, best practices, or checklists for tdd workflows tdd cycle\n\n## Do not use this skill when\n\n- The task is unrelated to tdd workflows tdd cycle\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\nExecute a comprehensive Test-Driven Development (TDD) workflow with strict red-green-refactor discipline:\n\n[Extended thinking: This workflow enforces test-first development through coordinated agent orchestration. Each phase of the TDD cycle is strictly enforced with fail-first verification, incremental implementation, and continuous refactoring. The workflow supports both single test and test suite approaches with configurable coverage thresholds.]\n\n## Configuration\n\n### Coverage Thresholds\n- Minimum line coverage: 80%\n- Minimum branch coverage: 75%\n- Critical path coverage: 100%\n\n### Refactoring Triggers\n- Cyclomatic complexity > 10\n- Method length > 20 lines\n- Class length > 200 lines\n- Duplicate code blocks > 3 lines\n\n## Phase 1: Test Specification and Design\n\n### 1. Requirements Analysis\n- Use Task tool with subagent_type=\"comprehensive-review::architect-review\"\n- Prompt: \"Analyze requirements for: $ARGUMENTS. Define acceptance criteria, identify edge cases, and create test scenarios. Output a comprehensive test specification.\"\n- Output: Test specification, acceptance criteria, edge case matrix\n- Validation: Ensure all requirements have corresponding test scenarios\n\n### 2. Test Architecture Design\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Design test architecture for: $ARGUMENTS based on test specification. Define test structure, fixtures, mocks, and test data strategy. Ensure testability and maintainability.\"\n- Output: Test architecture, fixture design, mock strategy\n- Validation: Architecture supports isolated, fast, reliable tests\n\n## Phase 2: RED - Write Failing Tests\n\n### 3. Write Unit Tests (Failing)\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Write FAILING unit tests for: $ARGUMENTS. Tests must fail initially. Include edge cases, error scenarios, and happy paths. DO NOT implement production code.\"\n- Output: Failing unit tests, test documentation\n- **CRITICAL**: Verify all tests fail with expected error messages\n\n### 4. Verify Test Failure\n- Use Task tool with subagent_type=\"tdd-workflows::code-reviewer\"\n- Prompt: \"Verify that all tests for: $ARGUMENTS are failing correctly. Ensure failures are for the right reasons (missing implementation, not test errors). Confirm no false positives.\"\n- Output: Test failure verification report\n- **GATE**: Do not proceed until all tests fail appropriately\n\n## Phase 3: GREEN - Make Tests Pass\n\n### 5. Minimal Implementation\n- Use Task tool with subagent_type=\"backend-development::backend-architect\"\n- Prompt: \"Implement MINIMAL code to make tests pass for: $ARGUMENTS. Focus only on making tests green. Do not add extra features or optimizations. Keep it simple.\"\n- Output: Minimal working implementation\n- Constraint: No code beyond what's needed to pass tests\n\n### 6. Verify Test Success\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Run all tests for: $ARGUMENTS and verify they pass. Check test coverage metrics. Ensure no tests were accidentally broken.\"\n- Output: Test execution report, coverage metrics\n- **GATE**: All tests must pass before proceeding\n\n## Phase 4: REFACTOR - Improve Code Quality\n\n### 7. Code Refactoring\n- Use Task tool with subagent_type=\"tdd-workflows::code-reviewer\"\n- Prompt: \"Refactor implementation for: $ARGUMENTS while keeping tests green. Apply SOLID principles, remove duplication, improve naming, and optimize performance. Run tests after each refactoring.\"\n- Output: Refactored code, refactoring report\n- Constraint: Tests must remain green throughout\n\n### 8. Test Refactoring\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Refactor tests for: $ARGUMENTS. Remove test duplication, improve test names, extract common fixtures, and enhance test readability. Ensure tests still provide same coverage.\"\n- Output: Refactored tests, improved test structure\n- Validation: Coverage metrics unchanged or improved\n\n## Phase 5: Integration and System Tests\n\n### 9. Write Integration Tests (Failing First)\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Write FAILING integration tests for: $ARGUMENTS. Test component interactions, API contracts, and data flow. Tests must fail initially.\"\n- Output: Failing integration tests\n- Validation: Tests fail due to missing integration logic\n\n### 10. Implement Integration\n- Use Task tool with subagent_type=\"backend-development::backen",
  "tags": [
    "api",
    "ai",
    "agent",
    "workflow",
    "design",
    "document",
    "rag"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:00:43.272Z"
}