{
  "id": "antigravity-systems-programming-rust-project",
  "name": "systems-programming-rust-project",
  "slug": "systems-programming-rust-project",
  "description": "You are a Rust project architecture expert specializing in scaffolding production-ready Rust applications. Generate complete project structures with cargo tooling, proper module organization, testing",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/systems-programming-rust-project",
  "content": "\n# Rust Project Scaffolding\n\nYou are a Rust project architecture expert specializing in scaffolding production-ready Rust applications. Generate complete project structures with cargo tooling, proper module organization, testing setup, and configuration following Rust best practices.\n\n## Use this skill when\n\n- Working on rust project scaffolding tasks or workflows\n- Needing guidance, best practices, or checklists for rust project scaffolding\n\n## Do not use this skill when\n\n- The task is unrelated to rust project scaffolding\n- You need a different domain or tool outside this scope\n\n## Context\n\nThe user needs automated Rust project scaffolding that creates idiomatic, safe, and performant applications with proper structure, dependency management, testing, and build configuration. Focus on Rust idioms and scalable architecture.\n\n## Requirements\n\n$ARGUMENTS\n\n## Instructions\n\n### 1. Analyze Project Type\n\nDetermine the project type from user requirements:\n- **Binary**: CLI tools, applications, services\n- **Library**: Reusable crates, shared utilities\n- **Workspace**: Multi-crate projects, monorepos\n- **Web API**: Actix/Axum web services, REST APIs\n- **WebAssembly**: Browser-based applications\n\n### 2. Initialize Project with Cargo\n\n```bash\n# Create binary project\ncargo new project-name\ncd project-name\n\n# Or create library\ncargo new --lib library-name\n\n# Initialize git (cargo does this automatically)\n# Add to .gitignore if needed\necho \"/target\" >> .gitignore\necho \"Cargo.lock\" >> .gitignore  # For libraries only\n```\n\n### 3. Generate Binary Project Structure\n\n```\nbinary-project/\n├── Cargo.toml\n├── README.md\n├── src/\n│   ├── main.rs\n│   ├── config.rs\n│   ├── cli.rs\n│   ├── commands/\n│   │   ├── mod.rs\n│   │   ├── init.rs\n│   │   └── run.rs\n│   ├── error.rs\n│   └── lib.rs\n├── tests/\n│   ├── integration_test.rs\n│   └── common/\n│       └── mod.rs\n├── benches/\n│   └── benchmark.rs\n└── examples/\n    └── basic_usage.rs\n```\n\n**Cargo.toml**:\n```toml\n[package]\nname = \"project-name\"\nversion = \"0.1.0\"\nedition = \"2021\"\nrust-version = \"1.75\"\nauthors = [\"Your Name <email@example.com>\"]\ndescription = \"Project description\"\nlicense = \"MIT OR Apache-2.0\"\nrepository = \"https://github.com/user/project-name\"\n\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\ntokio = { version = \"1.36\", features = [\"full\"] }\nanyhow = \"1.0\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n\n[dev-dependencies]\ncriterion = \"0.5\"\n\n[[bench]]\nname = \"benchmark\"\nharness = false\n\n[profile.release]\nopt-level = 3\nlto = true\ncodegen-units = 1\n```\n\n**src/main.rs**:\n```rust\nuse anyhow::Result;\nuse clap::Parser;\n\nmod cli;\nmod commands;\nmod config;\nmod error;\n\nuse cli::Cli;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    match cli.command {\n        cli::Commands::Init(args) => commands::init::execute(args).await?,\n        cli::Commands::Run(args) => commands::run::execute(args).await?,\n    }\n\n    Ok(())\n}\n```\n\n**src/cli.rs**:\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"project-name\")]\n#[command(about = \"Project description\", long_about = None)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Subcommand)]\npub enum Commands {\n    /// Initialize a new project\n    Init(InitArgs),\n    /// Run the application\n    Run(RunArgs),\n}\n\n#[derive(Parser)]\npub struct InitArgs {\n    /// Project name\n    #[arg(short, long)]\n    pub name: String,\n}\n\n#[derive(Parser)]\npub struct RunArgs {\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n}\n```\n\n**src/error.rs**:\n```rust\nuse std::fmt;\n\n#[derive(Debug)]\npub enum AppError {\n    NotFound(String),\n    InvalidInput(String),\n    IoError(std::io::Error),\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            AppError::NotFound(msg) => write!(f, \"Not found: {}\", msg),\n            AppError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            AppError::IoError(e) => write!(f, \"IO error: {}\", e),\n        }\n    }\n}\n\nimpl std::error::Error for AppError {}\n\npub type Result<T> = std::result::Result<T, AppError>;\n```\n\n### 4. Generate Library Project Structure\n\n```\nlibrary-name/\n├── Cargo.toml\n├── README.md\n├── src/\n│   ├── lib.rs\n│   ├── core.rs\n│   ├── utils.rs\n│   └── error.rs\n├── tests/\n│   └── integration_test.rs\n└── examples/\n    └── basic.rs\n```\n\n**Cargo.toml for Library**:\n```toml\n[package]\nname = \"library-name\"\nversion = \"0.1.0\"\nedition = \"2021\"\nrust-version = \"1.75\"\n\n[dependencies]\n# Keep minimal for libraries\n\n[dev-dependencies]\ntokio-test = \"0.4\"\n\n[lib]\nname = \"library_name\"\npath = \"src/lib.rs\"\n```\n\n**src/lib.rs**:\n```rust\n//! Library documentation\n//!\n//! # Examples\n//!\n//! ```\n//! use library_name::core::CoreType;\n//!\n//! let instance = CoreType::new();\n//! ```\n\npub mod core;\npub mod error;\npub mod utils;\n\npub use core::CoreType;\npub use error::{Error, Result};\n\n#[cfg(test)]\nmod tests {\n    use ",
  "tags": [
    "api",
    "ai",
    "workflow",
    "document"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:00:41.209Z"
}