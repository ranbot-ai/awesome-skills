{
  "id": "antigravity-langchain-architecture",
  "name": "langchain-architecture",
  "slug": "langchain-architecture",
  "description": "Design LLM applications using the LangChain framework with agents, memory, and tool integration patterns. Use when building LangChain applications, implementing AI agents, or creating complex LLM workflows.",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/langchain-architecture",
  "content": "\n# LangChain Architecture\n\nMaster the LangChain framework for building sophisticated LLM applications with agents, chains, memory, and tool integration.\n\n## Do not use this skill when\n\n- The task is unrelated to langchain architecture\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\n## Use this skill when\n\n- Building autonomous AI agents with tool access\n- Implementing complex multi-step LLM workflows\n- Managing conversation memory and state\n- Integrating LLMs with external data sources and APIs\n- Creating modular, reusable LLM application components\n- Implementing document processing pipelines\n- Building production-grade LLM applications\n\n## Core Concepts\n\n### 1. Agents\nAutonomous systems that use LLMs to decide which actions to take.\n\n**Agent Types:**\n- **ReAct**: Reasoning + Acting in interleaved manner\n- **OpenAI Functions**: Leverages function calling API\n- **Structured Chat**: Handles multi-input tools\n- **Conversational**: Optimized for chat interfaces\n- **Self-Ask with Search**: Decomposes complex queries\n\n### 2. Chains\nSequences of calls to LLMs or other utilities.\n\n**Chain Types:**\n- **LLMChain**: Basic prompt + LLM combination\n- **SequentialChain**: Multiple chains in sequence\n- **RouterChain**: Routes inputs to specialized chains\n- **TransformChain**: Data transformations between steps\n- **MapReduceChain**: Parallel processing with aggregation\n\n### 3. Memory\nSystems for maintaining context across interactions.\n\n**Memory Types:**\n- **ConversationBufferMemory**: Stores all messages\n- **ConversationSummaryMemory**: Summarizes older messages\n- **ConversationBufferWindowMemory**: Keeps last N messages\n- **EntityMemory**: Tracks information about entities\n- **VectorStoreMemory**: Semantic similarity retrieval\n\n### 4. Document Processing\nLoading, transforming, and storing documents for retrieval.\n\n**Components:**\n- **Document Loaders**: Load from various sources\n- **Text Splitters**: Chunk documents intelligently\n- **Vector Stores**: Store and retrieve embeddings\n- **Retrievers**: Fetch relevant documents\n- **Indexes**: Organize documents for efficient access\n\n### 5. Callbacks\nHooks for logging, monitoring, and debugging.\n\n**Use Cases:**\n- Request/response logging\n- Token usage tracking\n- Latency monitoring\n- Error handling\n- Custom metrics collection\n\n## Quick Start\n\n```python\nfrom langchain.agents import AgentType, initialize_agent, load_tools\nfrom langchain.llms import OpenAI\nfrom langchain.memory import ConversationBufferMemory\n\n# Initialize LLM\nllm = OpenAI(temperature=0)\n\n# Load tools\ntools = load_tools([\"serpapi\", \"llm-math\"], llm=llm)\n\n# Add memory\nmemory = ConversationBufferMemory(memory_key=\"chat_history\")\n\n# Create agent\nagent = initialize_agent(\n    tools,\n    llm,\n    agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,\n    memory=memory,\n    verbose=True\n)\n\n# Run agent\nresult = agent.run(\"What's the weather in SF? Then calculate 25 * 4\")\n```\n\n## Architecture Patterns\n\n### Pattern 1: RAG with LangChain\n```python\nfrom langchain.chains import RetrievalQA\nfrom langchain.document_loaders import TextLoader\nfrom langchain.text_splitter import CharacterTextSplitter\nfrom langchain.vectorstores import Chroma\nfrom langchain.embeddings import OpenAIEmbeddings\n\n# Load and process documents\nloader = TextLoader('documents.txt')\ndocuments = loader.load()\n\ntext_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=200)\ntexts = text_splitter.split_documents(documents)\n\n# Create vector store\nembeddings = OpenAIEmbeddings()\nvectorstore = Chroma.from_documents(texts, embeddings)\n\n# Create retrieval chain\nqa_chain = RetrievalQA.from_chain_type(\n    llm=llm,\n    chain_type=\"stuff\",\n    retriever=vectorstore.as_retriever(),\n    return_source_documents=True\n)\n\n# Query\nresult = qa_chain({\"query\": \"What is the main topic?\"})\n```\n\n### Pattern 2: Custom Agent with Tools\n```python\nfrom langchain.agents import Tool, AgentExecutor\nfrom langchain.agents.react.base import ReActDocstoreAgent\nfrom langchain.tools import tool\n\n@tool\ndef search_database(query: str) -> str:\n    \"\"\"Search internal database for information.\"\"\"\n    # Your database search logic\n    return f\"Results for: {query}\"\n\n@tool\ndef send_email(recipient: str, content: str) -> str:\n    \"\"\"Send an email to specified recipient.\"\"\"\n    # Email sending logic\n    return f\"Email sent to {recipient}\"\n\ntools = [search_database, send_email]\n\nagent = initialize_agent(\n    tools,\n    llm,\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n    verbose=True\n)\n```\n\n### Pattern 3: Multi-Step Chain\n```python\nfrom langchain.chains import LLMChain, SequentialChain\nfrom langchain.prompts import PromptTemplate\n\n# Step 1: Extract key information\nextract_prompt = PromptTemplate(\n    input_variables=[\"text\"],\n    templat",
  "tags": [
    "python",
    "react",
    "api",
    "ai",
    "agent",
    "llm",
    "workflow",
    "template",
    "design",
    "document"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T06:59:27.258Z"
}