{
  "id": "antigravity-autonomous-agent-patterns",
  "name": "autonomous-agent-patterns",
  "slug": "autonomous-agent-patterns",
  "description": "Design patterns for building autonomous coding agents. Covers tool integration, permission systems, browser automation, and human-in-the-loop workflows. Use when building AI agents, designing tool APIs, implementing permission systems, or creating autonomous coding assistants.",
  "category": "AI & Agents",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/autonomous-agent-patterns",
  "content": "\n# ðŸ•¹ï¸ Autonomous Agent Patterns\n\n> Design patterns for building autonomous coding agents, inspired by [Cline](https://github.com/cline/cline) and [OpenAI Codex](https://github.com/openai/codex).\n\n## When to Use This Skill\n\nUse this skill when:\n\n- Building autonomous AI agents\n- Designing tool/function calling APIs\n- Implementing permission and approval systems\n- Creating browser automation for agents\n- Designing human-in-the-loop workflows\n\n---\n\n## 1. Core Agent Architecture\n\n### 1.1 Agent Loop\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                     AGENT LOOP                               â”‚\nâ”‚                                                              â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚\nâ”‚  â”‚  Think   â”‚â”€â”€â”€â–¶â”‚  Decide  â”‚â”€â”€â”€â–¶â”‚   Act    â”‚              â”‚\nâ”‚  â”‚ (Reason) â”‚    â”‚ (Plan)   â”‚    â”‚ (Execute)â”‚              â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚\nâ”‚       â–²                               â”‚                     â”‚\nâ”‚       â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚                     â”‚\nâ”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Observe  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ”‚                 â”‚ (Result) â”‚                                â”‚\nâ”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n```python\nclass AgentLoop:\n    def __init__(self, llm, tools, max_iterations=50):\n        self.llm = llm\n        self.tools = {t.name: t for t in tools}\n        self.max_iterations = max_iterations\n        self.history = []\n\n    def run(self, task: str) -> str:\n        self.history.append({\"role\": \"user\", \"content\": task})\n\n        for i in range(self.max_iterations):\n            # Think: Get LLM response with tool options\n            response = self.llm.chat(\n                messages=self.history,\n                tools=self._format_tools(),\n                tool_choice=\"auto\"\n            )\n\n            # Decide: Check if agent wants to use a tool\n            if response.tool_calls:\n                for tool_call in response.tool_calls:\n                    # Act: Execute the tool\n                    result = self._execute_tool(tool_call)\n\n                    # Observe: Add result to history\n                    self.history.append({\n                        \"role\": \"tool\",\n                        \"tool_call_id\": tool_call.id,\n                        \"content\": str(result)\n                    })\n            else:\n                # No more tool calls = task complete\n                return response.content\n\n        return \"Max iterations reached\"\n\n    def _execute_tool(self, tool_call) -> Any:\n        tool = self.tools[tool_call.name]\n        args = json.loads(tool_call.arguments)\n        return tool.execute(**args)\n```\n\n### 1.2 Multi-Model Architecture\n\n```python\nclass MultiModelAgent:\n    \"\"\"\n    Use different models for different purposes:\n    - Fast model for planning\n    - Powerful model for complex reasoning\n    - Specialized model for code generation\n    \"\"\"\n\n    def __init__(self):\n        self.models = {\n            \"fast\": \"gpt-3.5-turbo\",      # Quick decisions\n            \"smart\": \"gpt-4-turbo\",        # Complex reasoning\n            \"code\": \"claude-3-sonnet\",     # Code generation\n        }\n\n    def select_model(self, task_type: str) -> str:\n        if task_type == \"planning\":\n            return self.models[\"fast\"]\n        elif task_type == \"analysis\":\n            return self.models[\"smart\"]\n        elif task_type == \"code\":\n            return self.models[\"code\"]\n        return self.models[\"smart\"]\n```\n\n---\n\n## 2. Tool Design Patterns\n\n### 2.1 Tool Schema\n\n```python\nclass Tool:\n    \"\"\"Base class for agent tools\"\"\"\n\n    @property\n    def schema(self) -> dict:\n        \"\"\"JSON Schema for the tool\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": self._get_parameters(),\n                \"required\": self._get_required()\n            }\n        }\n\n    def execute(self, **kwargs) -> ToolResult:\n        \"\"\"Execute the tool and return result\"\"\"\n        raise NotImplementedError\n\nclass ReadFileTool(Tool):\n    name = \"read_file\"\n    description = \"Read the contents of a file from the filesystem\"\n\n    def _get_parameters(self):\n        return {\n            \"path\": {\n                \"type\": \"string\",\n                \"description\": \"Absolute path to the file\"\n            },\n            \"start_line\": {\n                \"type\": \"integer\",\n                \"description\": \"Line to start reading from (1-indexed)\"\n            },\n            \"end_line\": {\n                \"type\": \"integer\",\n                \"description\": \"Line to stop reading at (inclusive)\"\n            }\n        }\n\n    def _get_required(self):\n        return [\"path\"]\n\n    def execute(self, path: str, start_line: int = None, end_line: int = None) -> ToolResult:\n        try:\n            with open(path, 'r') as f",
  "tags": [
    "python",
    "node",
    "markdown",
    "api",
    "mcp",
    "claude",
    "ai",
    "agent",
    "llm",
    "gpt"
  ],
  "useCases": [
    "Building autonomous AI agents",
    "Designing tool/function calling APIs",
    "Implementing permission and approval systems",
    "Creating browser automation for agents",
    "Designing human-in-the-loop workflows"
  ],
  "scrapedAt": "2026-01-26T13:16:45.743Z"
}