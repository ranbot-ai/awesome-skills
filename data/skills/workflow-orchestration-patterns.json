{
  "id": "antigravity-workflow-orchestration-patterns",
  "name": "workflow-orchestration-patterns",
  "slug": "workflow-orchestration-patterns",
  "description": "Design durable workflows with Temporal for distributed systems. Covers workflow vs activity separation, saga patterns, state management, and determinism constraints. Use when building long-running processes, distributed transactions, or microservice orchestration.",
  "category": "Document Processing",
  "source": "antigravity",
  "repoUrl": "https://github.com/sickn33/antigravity-awesome-skills",
  "skillUrl": "https://github.com/sickn33/antigravity-awesome-skills/tree/main/skills/workflow-orchestration-patterns",
  "content": "\n# Workflow Orchestration Patterns\n\nMaster workflow orchestration architecture with Temporal, covering fundamental design decisions, resilience patterns, and best practices for building reliable distributed systems.\n\n## Use this skill when\n\n- Working on workflow orchestration patterns tasks or workflows\n- Needing guidance, best practices, or checklists for workflow orchestration patterns\n\n## Do not use this skill when\n\n- The task is unrelated to workflow orchestration patterns\n- You need a different domain or tool outside this scope\n\n## Instructions\n\n- Clarify goals, constraints, and required inputs.\n- Apply relevant best practices and validate outcomes.\n- Provide actionable steps and verification.\n- If detailed examples are required, open `resources/implementation-playbook.md`.\n\n## When to Use Workflow Orchestration\n\n### Ideal Use Cases (Source: docs.temporal.io)\n\n- **Multi-step processes** spanning machines/services/databases\n- **Distributed transactions** requiring all-or-nothing semantics\n- **Long-running workflows** (hours to years) with automatic state persistence\n- **Failure recovery** that must resume from last successful step\n- **Business processes**: bookings, orders, campaigns, approvals\n- **Entity lifecycle management**: inventory tracking, account management, cart workflows\n- **Infrastructure automation**: CI/CD pipelines, provisioning, deployments\n- **Human-in-the-loop** systems requiring timeouts and escalations\n\n### When NOT to Use\n\n- Simple CRUD operations (use direct API calls)\n- Pure data processing pipelines (use Airflow, batch processing)\n- Stateless request/response (use standard APIs)\n- Real-time streaming (use Kafka, event processors)\n\n## Critical Design Decision: Workflows vs Activities\n\n**The Fundamental Rule** (Source: temporal.io/blog/workflow-engine-principles):\n\n- **Workflows** = Orchestration logic and decision-making\n- **Activities** = External interactions (APIs, databases, network calls)\n\n### Workflows (Orchestration)\n\n**Characteristics:**\n\n- Contain business logic and coordination\n- **MUST be deterministic** (same inputs → same outputs)\n- **Cannot** perform direct external calls\n- State automatically preserved across failures\n- Can run for years despite infrastructure failures\n\n**Example workflow tasks:**\n\n- Decide which steps to execute\n- Handle compensation logic\n- Manage timeouts and retries\n- Coordinate child workflows\n\n### Activities (External Interactions)\n\n**Characteristics:**\n\n- Handle all external system interactions\n- Can be non-deterministic (API calls, DB writes)\n- Include built-in timeouts and retry logic\n- **Must be idempotent** (calling N times = calling once)\n- Short-lived (seconds to minutes typically)\n\n**Example activity tasks:**\n\n- Call payment gateway API\n- Write to database\n- Send emails or notifications\n- Query external services\n\n### Design Decision Framework\n\n```\nDoes it touch external systems? → Activity\nIs it orchestration/decision logic? → Workflow\n```\n\n## Core Workflow Patterns\n\n### 1. Saga Pattern with Compensation\n\n**Purpose**: Implement distributed transactions with rollback capability\n\n**Pattern** (Source: temporal.io/blog/compensating-actions-part-of-a-complete-breakfast-with-sagas):\n\n```\nFor each step:\n  1. Register compensation BEFORE executing\n  2. Execute the step (via activity)\n  3. On failure, run all compensations in reverse order (LIFO)\n```\n\n**Example: Payment Workflow**\n\n1. Reserve inventory (compensation: release inventory)\n2. Charge payment (compensation: refund payment)\n3. Fulfill order (compensation: cancel fulfillment)\n\n**Critical Requirements:**\n\n- Compensations must be idempotent\n- Register compensation BEFORE executing step\n- Run compensations in reverse order\n- Handle partial failures gracefully\n\n### 2. Entity Workflows (Actor Model)\n\n**Purpose**: Long-lived workflow representing single entity instance\n\n**Pattern** (Source: docs.temporal.io/evaluate/use-cases-design-patterns):\n\n- One workflow execution = one entity (cart, account, inventory item)\n- Workflow persists for entity lifetime\n- Receives signals for state changes\n- Supports queries for current state\n\n**Example Use Cases:**\n\n- Shopping cart (add items, checkout, expiration)\n- Bank account (deposits, withdrawals, balance checks)\n- Product inventory (stock updates, reservations)\n\n**Benefits:**\n\n- Encapsulates entity behavior\n- Guarantees consistency per entity\n- Natural event sourcing\n\n### 3. Fan-Out/Fan-In (Parallel Execution)\n\n**Purpose**: Execute multiple tasks in parallel, aggregate results\n\n**Pattern:**\n\n- Spawn child workflows or parallel activities\n- Wait for all to complete\n- Aggregate results\n- Handle partial failures\n\n**Scaling Rule** (Source: temporal.io/blog/workflow-engine-principles):\n\n- Don't scale individual workflows\n- For 1M tasks: spawn 1K child workflows × 1K tasks each\n- Keep each workflow bounded\n\n### 4. Async Callback Pattern\n\n**Purpose**: Wait for external event or human approval\n\n**Pattern:**\n\n- Workflow sends request and waits for signal\n- Ex",
  "tags": [
    "api",
    "ai",
    "llm",
    "automation",
    "workflow",
    "design",
    "document",
    "cro"
  ],
  "useCases": [],
  "scrapedAt": "2026-01-29T07:01:04.583Z"
}